\chapterimage{chapter_head_2.pdf} % Chapter heading image

\chapter{Klasar og hlutir}\index{Klasar og hlutir}\label{k:klasar}
Forritun snýst um að meðhöndla gögn, hingað til höfum við kynnst nokkrum gagnatögum (t.d. strengir og listar), þær gegna mismunandi hlutverkum og bjóða upp á mismunandi aðgerðir til að vinna með gögnin.
Þessar innbyggðu týpur duga þó ekki alltaf og því er mikilvægt að vita að þegar við forritum getum við smíðað okkar eigin.
Þannig getum við aðlagað týpurnar okkar að þeim gögnum sem forritið okkar meðhöndlar og útfært okkar eigin aðferðir á þær.
Klasar gera forriturum kleift að skilgreina sína eigin hluti í flestum hlutbundnum málum, Python er hlutbundið forritunarmál.
Til þess að læra á hvernig eigi að búa til klasa þarf að átta sig á til hvers þeir eru nytsamlegir.

Gagnlegt er að hugsa sér klasa sem skilgreiningu eða uppskrift alveg eins og föll.
Skilgreiningin ein og sér gerir ekki neitt, það er ekki fyrr en við búum okkur til ákveðna útgáfu sem við getum farið að vinna með hana.
Gott dæmi um það er skilgreiningin á rétti á matseðli á veitingastað, textinn á matseðlinum er eingöngu hvað er í boði en er ekki útgáfa af matnum sjálfum.

Klasar eru hlutir sem hugsaðir eru til þess að búa til eintök af og geyma þannig eitthvert ástand og mögulega hafa áhrif á það.
Hugmyndin er að eiga hlut eða \emph{tilvik}, eina tiltekna útgáfu, sem má framkvæma aðgerðir á og eitthvað ástand hlutarins breytist eftir því hvað var gert, þannig er hægt að búa til mörg eintök af sama klasanum og láta hvert tilvik verða fyrir mismunandi áhrifum\footnote{Athuga þarf sérstaklega gildissvið þegar klasar eru annarsvegar, gildissvið í Python geta verið ögn ruglingsleg en við munum ekki beita klösum á það sérhæfðan máta að við lendum í miklum vandræðum.
Hér er tilvalið að skoða ,,meta programming''}.

\section{Klasar skilgreindir}\index{Klasar skilgreindir}\label{uk:klasar-skilgreindir}

Klasar nota lykilorðið \textbf{class} og eru skilgreindir með því orði, allt sem tilheyrir klasanum er inndregið undir honum.

\begin{lstlisting}[caption=Klasar skilgreindir, label=lst:klasar-skilgreindir-tegund]
class Bíll:
	tegund = "Citroen"

fyrsti_billinn = Bíll()
print(fyrsti_billinn.tegund)
\end{lstlisting}
\lstset{style=uttak}
\begin{lstlisting}
Citroen
\end{lstlisting}
\lstset{style=venjulegt}

Hugsum okkur að við búum til skilgreiningu á bíl, hann þarf að vera af einhverri tegund, skoðum línur 1-2 í kóðabút \ref{lst:klasar-skilgreindir-tegund}.
Svo viljum við fá tilvik af skilgreiningunni í hendurnar (lína 3), þá búum okkur til breytu sem fær gildi eins og við höfum gert hundrað sinnum áður, nema núna er gildið sem breytan fær nafnið á klasanum okkar ásamt svigum eins og við séum að kalla í hann.
Prófið núna að búa til annað tilvik af klasanum \texttt{Bíll} án þess að nota svigana og prófið þá að prenta út það sem \texttt{type} skilar fyrir breyturnar tvær.

\begin{lstlisting}[caption=Klasar skilgreindir, label=lst:klasar-skilgreindir-subaru]
class Bíll:
	tegund = "Citroen"
	
fyrsti_billinn = Bíll()
print(fyrsti_billinn.tegund)
annar_bill = Bíll()
annar_bill.tegund = "Subaru"
print(annar_bill.tegund)
\end{lstlisting}
\lstset{style=uttak}
\begin{lstlisting}
Citroen
Subaru
\end{lstlisting}
\lstset{style=venjulegt}

Breytan \texttt{fyrsti\_bilinn} kemur ekki í veg fyrir það að við getum átt fleiri bíla, en hún heldur utan um ástandið á nákvæmlega þessum bíl okkar.
Segjum að við fáum okkur svo annan bíl, þá getum við búið til aðra breytu (lína 6) í kóðabút \ref{lst:klasar-skilgreindir-subaru} fyrir annað tilvik af klasanum.
Bílarnir eru, fyrir okkur, óaðgreinanlegir í línu 6\footnote{Þar sem ekki hefur verið útfærð \_\_eq\_\_ aðferðin þá er notast við id() fallið úr type klasanum sem klasinn okkar erfir frá bakvið tjöldin.
Við skoðum erfðir betur seinna í kaflanum.} en það breytist svo snarlega þegar við endurskilgreinum \emph{klasabreytuna}\footnote{Í öðrum hlutbundnum málum er venjulega talað um klasafasta en í Python er auðvelt að breyta þeim svo við hæfi að nota annað orð en klasa\textbf{fasti}} í línu 7, \texttt{tegund}.

Prófið nú að skipta um gildi á klasabreytunni \texttt{tegund} fyrir ykkar eigið tilvik af \texttt{Bíll}.

Þá skulum við skoða dálítið sérkennilegt fyrirbæri í Python, það er að við getum endurskilgreint klasabreyturnar okkar, sem hefur áhrif á öll tilvikin okkar.
Til að skoða það skulum við nota aftur kóðann úr kóðabút \ref{lst:klasar-skilgreindir-tegund}.

\begin{lstlisting}[caption=Klasar skilgreindir, label=lst:klasar-skilgreindir-tegund2]
class Bíll:
	tegund = "Citroen"
	
fyrsti_billinn = Bíll()
print(fyrsti_billinn.tegund)
Bíll.tegund = "Volvo"
print(fyrsti_billinn.tegund)
\end{lstlisting}
\lstset{style=uttak}
\begin{lstlisting}
Citroen
Volvo
\end{lstlisting}
\lstset{style=venjulegt}

Hér sjáum við hvernig tilvikið okkar, \texttt{fyrsti\_billinn}, af bílaklasanum breytist.
Í línu 5 er \texttt{tegund} "Citroen" en í línu 7 er það orðið að "Volvo".
Þetta gerist því að tilvikið okkar er af þessum klasa og hann breyttist í línu 6.
Við endurskilgreindum klasann og því breytast öll tilvik af honum í samræmi.

Nú eigum við tvær breytur sem við getum unnið með, kannski setja bensín á bílinn eða fylla á rúðuvökva og þá gerum við það við þá tilteknu breytu sem við ætlum að framkvæma þá aðgerð á.
En þessi skilgreining innihélt engar aðferðir, við sjáum það í hluta  \ref{uk:klasar-aðferðir}.

-----------------------------------------------------


Til þess að skilgreina klasa þarf einungis lykilorðið \textbf{class} og réttan inndrátt.
Í kóðabút \ref{lst:klasar-skilgreindir} sjáum við hvernig má búa til eins einfaldan klasa og mögulegt er og svo sjáum við í kóðabút \ref{lst:klasar-skilgreindir2} hvernig á að bæta við aðferð á klasa.

Við munum svo beita klösum á hnitmiðaðri máta með svo kölluðum \textit{töfra aðferð} (e. magic method, double underscore method, dunder method\footnote{þarna er orðunum double og under skeytt saman í dunder}) og skoða hvernig á að útbúa hlut með ákveðnum grunnupplýsingum.

\begin{lstlisting}[caption=Klasar skilgreindir, label=lst:klasar-skilgreindir2]
class Tala():
	x = 5
	def leggja_saman(self, x):
		print(self.x + x)

t = Tala()
t.leggja_saman(6)
\end{lstlisting}
\lstset{style=uttak}
\begin{lstlisting}
11
\end{lstlisting}
\lstset{style=venjulegt}

Tökum eftir hvernig breytan \texttt{t} er skilgreind í kóðabút \ref{lst:klasar-skilgreindir2}, hún er skilgreind eins og hvaða önnur breyta sem við höfum búið til áður.
En það sem kemur hinu megin við jafnaðarmerkið er eins og verið sé að kalla í fall.
Eina sem gefur til kynna að þetta sé ekki fall er að Klasi er með stórum staf.
Ef við gleymum að gera svigana þá fáum við ekki eintak af klasanum til að vinna með heldur fáum við nýja vísun á klasann sjálfan.
Það er við erum með nýtt nafn sem gerir það sama og breytan \texttt{Tala} gerir, annan vísi á \texttt{Tala} en ekki útgáfu til að vinna með.

Það er nafnavenja í Python að klasar séu nefndir með stórum staf, það auðveldar lestur fyrir mannfólk.

Þá sjáum við að í línu 7 er kallað í aðferðina \texttt{leggja\_saman}, hún tekur við einu viðfangi.
En ef við skoðum skilgreininguna á aðferðinni þá eru þar skilgreind tvö viðföng.
Fyrra viðfangið \texttt{self} er þarna notað fyrir klasann til að vita að það sé verið að tala um hann sjálfan, svo þarna inni eru tvö mismunandi x.
Fyrra x-ið er úr línu 2 og seinna x-ið er úr viðfanginu.
Þetta getur verið ruglandi en við munum sjá fleiri dæmi um þetta og vonandi verður þetta skýrara.

\section{Tilviksbreytur}\index{Tilveiksbreytur}\label{uk:klasar-tilviksbreytur}
Nú höfum við seð hvernig hægt er að búa til tilvik af klasa, en klasinn úr kóðabút \ref{lst:klasar-skilgreindir} er sérstaklega ber og gagnlítill.
En hvers eru klasar megnugir?

Athugum eftirfarandi samlíkingu áður en lengra er haldið.
Þegar við förum á veitingastað þá er okkur boðinn ákveðinn matseðill, við fáum að vita að það séu þrír réttir á matseðlinum (þrír klasar) og í þeim réttum eru ákveðin hráefni (tilviksbreytur) og þegar við pöntum okkur mat fáum við í hendurnar eitt tiltekið tilvik af skilgreiningunni á matseðlinum (tilvik af klasa).
Nú eru hráefnin kannski ekki okkur að skapi og við viljum fá að hafa áhrif á hvaða hráefni fara í réttinn okkar (okkar tiltekna tilvik) svo við gefum upp hvað við viljum fá (inntak) sem skilar sér í okkar tiltekna rétti (úttak).

Í þessari samlíkingu er matreiðslufólkið smiðurinn á bakvið klasann, í kóðabút \ref{lst:klasar-notkun} er aðferðin \_\_init\_\_ sá smiður.
Aðferðin smíðar fyrir okkur tilvik af klasanum með því inntaki sem hún fær.

\begin{lstlisting}[caption=Klasar skilgreindir með töfraaðferðinni \_\_init\_\_, label=lst:klasar-notkun]
class Samloka():
	# sjáum að hér er klasinn skilgreindur með svigum
	
	def __init__(self):
		# aðferðin tekur ekki við neinu og gerir ekkert
		pass
	
samlokan_min = Rettur()
# nú eigum við tilvik af klasanum Samloka í breytunni samlokan_min en við getum lítið gert við það, sjáum hvernig væri ef við hefðum einhver hráefni

class Samloka():
	def __init__(self, sosa, alegg):
		self.sosa = sosa
		self.alegg = alegg
		
samlokan_min = Samloka('bbq', ['skinka', 'ostur', 'paprika'])
# nú á ég tiltekna samloku sem hefur bbq sósu og þrjár áleggstegundir

# Athugum nú að matreiðslufólkið gæti boðið upp á einhverja ákveðna samloku
class Samloka_med_skinku():
	def __init__(self, sosa = "", alegg = ['skinka']):
		self.sosa = sosa
		self.alegg = alegg
		
skinku_samloka = Samloka_med_skinku('bbq')
# Nú eigum við tilvik af skinkusamloku sem er með bbq sósu og einu áleggi, skinku.
\end{lstlisting}

Samlíkingin okkar með samlokur á veitingastað er ágæt en nú skulum við skoða hvað er eiginlega í gangi í kóðabút \ref{lst:klasar-notkun}.
Fyrir það fyrsta er klasinn núna skilgreindur sem \textit{Samloka()} með svigum, það var ekki þannig í kóðabút \ref{lst:klasar-skilgreindir}.
Ástæðan er svipuð og í kafla \ref{k:segðir} þar sem mátti sleppa svigum utan um segðir fyrir skilyrðissetningar nema það væri þörf á þeim til útreiknings.
Klasar eiga möguleika á að \textbf{erfa} (e. inherit) frá öðrum klösum, við munum tala um það í undirkafla \ref{uk:klasar-erfðir}, og þeir erfa í grunninn allir frá klasanum \textit{Object}.
Það sem tómur svigi þýðir (eða að sleppa sviganum alfarið) er að klasi erfi ekki frá öðrum klasa.
Því er það upp á einstaklinginn komið að venja sig á að gera alltaf annað hvort, höfundur hefur vanið sig á tóma sviga en er það enginn heilagur sannleikur.

Næsta sem við þurfum að athuga er töfraaðferðin init og orðið \textit{self}.
Orðið self eitt og sér er ekki töfraorð, það má skipta því út fyrir eitthvað annnað, hins vegar hefur komist ákveðin venja á að nota það orð og gerir það kóða læsilegri að halda sig við það.
En hvað gerir orðið self?
Þetta orð er eins konar vísir fyrir klasann til að vita að það sér verið að nota skilgreiningar innan klasans sjálfs sem tilvikið hefur aðgang að.
Í klasanum Samloka eru viðföngin sosa (sem við búumst við að sé strengur án þess að athuga það neitt sérstaklega, sjá kafla \ref{k:villur} um hvernig megi taka á því) og alegg (sem við búumst við að sé listi af strengjum).
Ef notandinn gefur okkur ekkert inntak við gerð samlokunnar þá er ekki hægt að búa til tilvik af samlokunni, því klasinn býst við tveimur stöðubundnum viðföngum inn í aðferðina init og getur ekkert gert án þeirra nema skila villu (eins og klasinn er skilgreindur þarna).
Þegar við skilgreindum samlokan\_min þá sögðum við við klasasmiðinn (init) að við ætluðum að eiga aðgang að inntakinu okkar ('bbq' og ['skinka', 'ostur', 'paprika']).
Þannig að sosa inniheldur núna strenginn bbq fyrir þetta tiltekna tilvik af klasanum og þennan tiltekna lista af áleggstegundum.

Það þriðja og kannski það erfiðasta að skilja er að init aðferðin í klasanum Samloka\_med\_skinku tekur við nefndum viðföngum, eins og við sáum í kafla \ref{uk:föll-sjálfgefin}, sem hafa einhver tiltekin gildi nú þegar skilgreind.
Sem þýðir að við getum búið til einhverja óbreytta, staðlaða, sjálfgefna skinku samloku.
Við þurfum ekki að gefa neitt upp til þess að fá tilvikið í hendurnar, hins vegar ef okkur langar til þess að fá samloku með einhverri sósu og einhverju öðru áleggi þurfum við að gefa það upp og við getum gert það alveg eins og þegar við notum föll með sjálfgefnum/nefndum viðföngum.

\section{Aðferðir}\index{Aðferðir}\label{uk:klasar-aðferðir}
Við þekkjum aðferðir, við höfum séð þær notaðar á týpurnar sem við þekkjum, eins og .capitalize() á strengi, .sort() á lista og .get("x", "y") á orðabækur.
\todo{vera viss um að kynna .get í dict kafla}
Aðferðir eru í raun föll sem eru skilgrein inni í klösum og verka á hlutinn sem klasinn skilgreinir.

Nú ætlum við að skilgreina okkar eigin aðferðir á hlutina okkar.
Við ætlum að skoða aðferðir með tilliti til rafbíla.
Það sem við viljum geta gert þegar við búum til tilvik af rafbíl er að segja hvaða tegund hann hefur, hvaða árgerð hann er af, hversu mikla drægni hann hefur á 100km, hversu margar kílówatt stundir rafhlaðan er og hversu marga kílómetra er búið að aka bílnum.

\begin{lstlisting}[caption=Klasa aðferðir á rafbílaklasa, label=lst:klasar-aðferðir1]

class Rafbill():
	def __init__(self, tegund, model, draegni = 16.7, kws = 40, akstur = 0):
		self.tegund = tegund     
		self.argerd = argerd        
		self.eydsla = draegni/100     # hversu mörgum kw stundum bíllinn eyðir á 1 km
		self.kws = kws               # hversu mikil hleðsla kemst fyrir
		self.akstur = akstur         # km sem hafa verið eknir

	def breyta_tegund(self, ny_tegund):
		# kom í ljós að bíllinn var vitlaust skráður og það þarf að endurskoða gildið tegund
		self.tegund = ny_tegund

	def breyta_model(self, nytt_model):
		# kom í ljós að módelið var vitlaust skráð, og við lögum það
		self.model = nytt_model

	def keyra_km(self, km):
		# við aukum við keyrða kílómetra og við minnkum hleðsluna sem um nemur eyðslu á kílómetra bílsins
		self.akstur += km
		self.kws -= self.eydsla * km  

	def hlada_bilinn(self, kw):
		# Nú viljum við auka við hleðsluna í rafhlöðunni okkkar
		self.kws += kw
		
billinn_minn = Rafbill('Rafio', 2021) # við stillum bílinn í upphafi sem bara staðlaðan rafbíl frá fyrirtækinu Rafio.
billinn_minn.keyra_km(500)
print(billinn_minn.akstur) # skilar úttakinu 500
billinn_minn.hlada_bilinn(900)
print(billinn_minn.kws) # skilar úttakinu 856.5
\end{lstlisting}

Við viljum að það að aka bílnum ákveðna kílómetra hafi áhrif á stöðu rafhlöðunnar.
Við viljum líka geta hlaðið bílinn.
En eins og sést í kóðabút \ref{lst:klasar-aðferðir1} þá er hægt að hlaða bílinn endalaust og það er hægt að keyra hann endalaust líka.
Við settum engin takmörk á það hvað má keyra marga kílómetra, við höldum bara áfram að lækka hleðsluna og við leyfðum okkur svo að hlaða bílinn langt umfram það hversu margar kílówattstundir komast fyrir í rafhlöðunni.
Einnig er galli á þessum klasa að engin leið er til að halda utan um hvert er hámark hleðslu rafhlöðunnar.

En þetta dugar til að sýna fram á hvernig aðferðir eru skilgreindar, hvernig á að kalla í þær, hvernig þær hafa áhrif á tilveiksbreyturnar okkar og svo hvernig má kalla í tilviksbreyturnar til að sjá áhrifin.

Aðferðir þurfa þó ekki endilega að hafa áhrif á tilvikið okkar heldur geta skilað okkur til baka einhverri niðurstöðu, eins og flestar aðferðir á strengi (því við munum að strengir eru óbreytanlegir).

Engin aðferðanna í þessum klasa skilaði nokkurri niðurstöðu.

Tökum nú nýtt dæmi þar sem við skoðum ímyndað lestarkerfi á Íslandi.
Í þessu dæmi höldum við utan um tvennt með klösum, annars vegar lestarstöðvar sem hafa nöfn og eru í ákveðinni fjarlægð frá upphafsstöðinni á leiðinni sinni og hins vegar lestar sem eru á ákveðinni leið og eru staddar á ákveðinni stöð.
Í kóðabút \ref{lst:klasar-aðferðir-lestar} sjáum við hvernig aðferðir geta skilað einhverju án þess að hafa áhrif á tilviksbreytur og við sjáum einnig að smiðurinn init tekur bara við tveimur breytum frá notanda en skilgreinir þrjár tilviksbreytur, þetta er vegna þess að klasinn býður notandanum ekki að hafa áhrif á þessa breytu við smíð klasans.
Notandinn verður því að fá í hendurnar við grunnstillingu lest sem hefur ekki ferðast neitt.

\begin{lstlisting}[caption=Aðferðir kynntar með lestarkerfi, label=lst:klasar-aðferðir-lestar]
class Stod():
	def __init__(self, nafn, fjarlaegd):
		self.nafn = nafn
		self.fjarlaegd = fjarlaegd
		self.farnir_km = 0
	
	
class Lest():
	def __init__(self, leid, byrjunar_stod):
		self.leid = leid
		self.nuverandi_stod = byrjunar_stod
	
	def fara_til_numer(self, numer):
		# Þessi aðferð tekur við sætisnúmeri í leidalistanum self.leid
		#
		# Hún á að skila fjarlægðinni sem þarf að fara frá núverandi stöð að stöðinni í því sætisnúmeri
		return abs(self.leid[numer].fjarlaegd - self.nuverandi_stod.fjarlaegd)
	
	def fara_til_stod(self, stod):
		# Þessi aðferð tekur við hlut af týpunni Stod
		#
		# Hún á að skila fjarlægðinni sem þarf að fara frá núverandi stöð til að komast á stöðina í inntakinu
		return abs(stod.fjarlaegd - self.nuverandi_stod.fjarlaegd)
	
	def fara_til_stodvarnafn(self, stodvarnafn):
		# Þessi aðferð tekur við streng sem er stöðvarnafn
		#
		# Hún á að skila fjarlægðinni frá núverandi stöð að fjarlægðinni að stöðinni með nafnið í inntakinu
		for stod in self.leid:
			if(stod.nafn == stodvarnafn):
				return abs(stod.fjarlaegd - self.nuverandi_stod.fjarlaegd)
	
    # Það sem við viljum gera núna er að geta uppfært núverandi stöð á lestinni okkar
	# Og við viljum þá uppfæra hversu marga km hún hefur ferðast
	def ny_nuverandi_stod(self, stod):
		# aðferðin tekur við hlut af týpunni Stod
		#
		# Það sem aðferðin gerir er að uppfæra tilviksbreytuna nuverandi_stod sem inntaksstodina
		# og setja í tilviksbreytuna farnir_km hversu langt lestin þurfti að ferðast til að komast þangað
		#
		# Aðferðin á að skila km sem voru farnir til að komast þangað
		
		km = self.fara_til_stod(stod)
		self.farnir_km += km
		self.nuverandi_stod = stod
		
		return self.farnir_km
		
# Þetta eru lestarstöðvar
# Stöðvarnar hafa nöfn og fjarlægð frá aðalbrautarstöðinni í Reykjavík
reykjavik = Stod("Reykjavík", 0)
borgarnes = Stod("Borgarnes", 76)
akureyri = Stod("Akureyri", 388)
egilsstadir = Stod('Egilsstaðir', 636)

# leið 1, hún fer frá Reykjavík til Egilsstaða, með tveimur stoppum á milli
leid1 = [reykjavik, borgarnes, akureyri, egilsstadir]

# lest1 er ferðast þessa tilteknu leið og hún byrjar ferð sína í Reykjavík
lest1 = Lest(leid1, reykjavik)

lest1.fara_til_numer(3)
lest1.fara_til_stod(egilsstadir)
lest1.fara_til_stodvarnafn('Egilsstaðir')
# allar þessar aðferðir skila okkur tölunni 636

hofn = Stod('Höfn í Hornafirði', 820)
lest1.ny_stod_a_leid(hofn)
# skilar okkur lista af hlutum af týpunni Stod sem er nú nýja leið lestarinnar okkar lest1
\end{lstlisting}

\section{Töfra aðferðir}\index{Töfra aðferðir}\label{uk:klasar-töfra-aðferðir}
Nú höfum við séð hvernig á að skilgreina okkar eigin aðferðir á klasa.
Og við höfum verið að nota eina töfraaðferð til þess að smíða klasana okkar, init.
En það er til mýgrútur af töfraaðferðum sem við getum nýtt okkur til þess að gera klasana okkar nothæfari.
Í þessum kafla verða nokkrar slíkar teknar fyrir en alls ekki allar.
Við munum að töfraaðferðir (e. magic methods, double underscore methods, dunder methods) eru aðferðir sem eru með tveimur undirstrikum fyrir framan sig og aftan og gegna því hlutverki að útfæra innbyggða virkni.

Helst ber að nefna \_\_str\_\_ aðferðina, sem nemendur vilja oftast geta beitt strax og skilja ekki hvers vegna print skilar einhverju furðulegu.
Hingað til höfum við ekki verið að beita innbyggða fallinu print á klasana okkar í kóðabútum því að hún gerir ekkert skilmerkilegt ennþá.
Til þess að hún geri það þurfum við að útfæra töfraaðferðina str.
Það sem sú aðferð þarf að gera er að skila streng.
Nú er það upp á okkur komið hvað okkur finnst vera nógu merkilegar upplýsingar til þess að setja í strenginn sem á að prenta.
Hingað til þegar við beitum print fallinu höfum við verið að skoða úttak sem er af einhverri týpu sem við þekkjum, heiltölur eða strengir til dæmis.
En nú þegar við erum með okkar eigin klasa/hluti viljum við kannski fá einvherjar tilteknar upplýsingar í ákveðinni röð.

Skoðum kóðabút \ref{lst:klasar-str} þar sem við skilgreinum klasa sem heldur utan um rafbílinn okkar aftur, hins vegar ætlum við að sleppa aðferðunum á bílinn og bæta við nokkrum klasaföstum.
Klasafastar eru skilgreindir efst í klasa og er nafnavenjan með þá að nota eingöngu hástafi.
Það sem klasafastar gera fyrir okkur er að halda utan um breytur sem við viljum að séu aðgengilegar allsstaðar í klasanum, við viljum ekki endilega að þær séu hluti af inntaki frá notanda við smíð klasans og þeir gera yfirferð og prófun klasans auðveldari.
Með auðveldari prófunum er átt við að gildi séu ekki harðkóðuð víðsvegar og erfitt að skipta þeim út (eins og ef nota ætti ákveðna námundun á pí) heldur eru þau skilgreind á einum stað og auðvelt að átta sig á notkun þeirra (ef breytuheitin eru skýr).

\begin{lstlisting}[caption=Töfraaðferðin \_\_str\_\_, label=lst:klasar-str]
class Leikur():
	HAMARKS_LIF  = 100
	LAGMARKS_LIF = 0
	HAMARKS_PENINGUR = 9999
	LAGMARKS_PENINGUR = -9999
	
	def __init__(self, nafn, lif, peningur):
		self.nafn = nafn
		if(lif > self.HAMARKS_LIF or lif < self.LAGMARKS_LIF):
			# líf er utan þess sem er leyfilegt
			self.lif = 100
		else:
			self.lif = lif
		if(peningur > self.HAMARKS_PENINGUR or peningur < self.LAGMARKS_PENINGUR):
			# peningar er utan þess sem er leyfilegt
			self.peningur = 0
		else:
			self.peningur = peningur
	
	def __str__(self):
		return "Persónan heitir {} og á {} gullpeninga og hefur {} í líf".format(self.nafn, self.lif, self.peningur)

valborg = Leikur('Valborg', 200, 90)
print(valborg)
# skilar úttakinu "Persónan heitir Valborg og á 100 gullpeninga og hefur 90 í líf"
\end{lstlisting}

Ef þessarar str töfraaðferðar nyti ekki við þá væri úttakið á þessa leið \textit{<\_\_main\_\_.Leikur object at *minnissvæði*}.
Einnig er nýtt í þessum kóðabút að við vinnum eitthvað með inntakið frá notandanum áður en við stillum tilviksbreyturnar.
Þetta er ekki gert á nógu tryggan máta og við munum sjá í kafla \ref{k:villur} hvernig má meðhöndla inntak frá notanda þannig að vafalaust sé um réttinntak að ræða.
En við ætlum enn sem komið er að skoða hlutina á einfaldan og brothættan máta því við erum að kynnast svo mörgu nýju og óþarfi að gera allt kórrétt frá upphafi, mikilvægara er að byggja upp skilning hægt og rólega.

Það sem töfraaðferðirnar gera er að gera okkur kleyft að beita innbyggðum föllum eins og print og len á tilvik af klösunum okkar, og að beita hinum ýmsu virkjum (reikni-, samanburðar- og rökvikjum) milli tilvika eða annara gilda.




\section{Erfðir}\index{erfðir}\label{uk:klasar-erfðir}
Klasarnir okkar hafa hingað til verið skilgreindir með tómum svigum sem segir vélinni að þeir erfi ekki frá neinum klasa nema \textit{object} sem gerði það að verkum að við gátum útfært töfraaðferðir.

Nú ætlum við að skoða í kóðabút \ref{lst:klasar-erfðir} hvernig á að búa til \textbf{yfirklasa} (e. superclass) og \textbf{undirklasa} (e. subclass).
Við skoðum dæmi þar sem prentari er tekinn fyrir, það sem hann þarf að kunna að gera er að prenta út streng, segja til um blekhlutfallið sitt og minnka blekið um eitt prósentustig.
Þetta er alfarið æfing og því ekki endilega mjög raunhæft dæmi, en þar sem við erum að reyna að átta okkur á því hvað erfðir eru þá ætlum við að gera ráð fyrir því að við viljum að allir prentararnir okkar byrji með 100\% af bleki og hafi möguleikann á að lækka það.
Hins vegar er það ekki útrætt hvernig eigi að fara að því að prenta út og því ætlum við að útfæra sérstaka prentara sem eru eins og grunnprentarinn okkar (með tilliti til bleks) en meðhöndlar prentun á annan máta.

Undirliggjandi ástæður fyrir því að við myndum vilja gera þetta er sú að við viljum að einhver grunn virkni sé til staðar og sé aðgengileg, en það er einhver tiltekin virkni sem við viljum að sé öðruvísi.
Tökum sem dæmi klasa sem vinnur talar við gagnasafn og fær til baka helling af gögnum, vinnur gögnin einhvern veginn fyrir okkur og skilar þeim til okkar sem streng.
En við viljum kannski hafa þann möguleika að í stað þess að fá streng þá sendir klasinn gögnin sem tölvupóst eða býr til skjal á tölvunni sem geymir þau.
Þá myndum við nota erfðir fyrir þá tilteknu notkun.

\begin{lstlisting}[caption=Erfðir kynntar með klasanum Prentari, label=lst:klasar-erfðir]

class Prentari():
	BLEK = 100
	
	def prentun(self, strengur):
		print(strengur)
	
	def minnka_blek(self):
		self.BLEK -= 1
	
	def stada_bleks(self):
		print(self.BLEK)

p1 = Prentari()
p1.prentun('Valborg')
p1.minnka_blek()
print(p1.BLEK)

# úttakið verður
# Valborg
# 99

import random
class HandahofsPrentari(Prentari):
	def prentun(self, strengur):
		handahof = random.randint(1,5)
			for i in range(handahof):
				print(strengur)

p2 = HandahofsPrentari()
p2.prentun('Forritun')
p2.minnka_blek()
p2.stada_bleks()
# úttakið verður (handahófskennt)
# Forritun
# Forritun
# Forritun
# 99


class InntaksPrentari(Prentari):
	def prentun(self):
		strengur = input('hvað viltu prenta? ')
		fjoldi = int(input('hversu oft viltu prenta það? '))
		for i in range(fjoldi):
			print(strengur)

p3 = InntaksPrentari()
p3.prentun()
#> hvað viltu prenta? Tölva
#> hversu oft viltu prenta það? 3
print(p3.BLEK)
# úttakið verður
# Tölva
# Tölva
# Tölva
# 100
\end{lstlisting}

Í kóðabút \ref{lst:klasar-erfðir} er einungis verið að yfirskrifa aðferðina prentun því að það er aðferðin sem við vildum að væri með einhverjum sértækum hætti.
Við vildum ekki bara prenta út einu sinni heldur fá notandann til að segja okkur hversu oft og hvað á að prenta, eða geta gert það handahófskennt oft.

\subsubsection{Fjölmótun}
Tengt erfðum er þess virði að nefna fjölmótun (e. polymorphism) í Python.
Því það er fráburgðið t.d. C++ og Java.

Fjölmótun í Python virkar þannig að klasar þurfa ekki að erfa frá öðrum klösum til að haga sér eins og þeir.
Þetta er vegna þess að þegar vélin athugar hvort að einhver hlutur eigi einhver tiltekin eigindi skoðar hún klasann og þá klasa sem hann erfir frá (í röð) og skilar þeirri útgáfu af eigindinu sem finnst.

Til dæmis HandahofsPrentari og eigindið stada\_bleks(), þá er fyrst athugað innan klasans HandahofsPrentari og svo Prentari hvernig eigi að nota stada\_bleks.
Hins vegar ef við værum að vinna með eitthvað sem við vildum að hegðaði sér eins og prentari án þess að spá í öllu sem prentaraklasinn er hugsaður fyrir gætum við búið til hlut sem útfærir bara aðferðina stada\_bleks og erfir ekki frá neinum.
Hlutinn myndum við kannski kalla Blekathugun, og það sem aðferðin stada\_bleks gerir í þeim klasa er að skrifa stöðu bleksins, á einhverju tæki sem vill notfæra sér þessa aðferð, í tölvupóst.

Ef við tökum praktískara dæmi þá er hægt að sjá fyrir sér klasa sem sér um að vinna með gögn og til þess að geta sent gögnin frá þessum klasa á ákveðinn máta má láta hann fá hlut í hendurnar sem útfærir \textit{write} aðferð.
Klasinn sem útfærir write aðferðina þarf ekkert að gera annað en að útfæra þessa einu aðferð á einhvern ákveðinn máta og þá er hægt að fullvissa sig um að gögnin hafi verið skrifuð á þann máta.

Svo ef við viljum eiga nokkra mismunandi klasa sem allir kunna mismunandi write aðferðir þá þurfum við bara að ganga úr skugga um að gangavinnsluklasinn okkar fékk write fallið sem við vildum nota úr viðeigandi klasa.

Þetta er kallað \textbf{duck typing} og bjóða ekki öll forritunarmál upp á það.
Hugtakið kemur úr frasanum ,,if it looks lika a duck, quacks like a duck and walks like a duck, it's a duck''.
Hugmyndin er að klasinn sem útfærir einungis aðferðina write fyrir okkur er alveg jafn mikil önd eins og kóðasafnið \textit{os} sem sér um að vinna með skrársafnið og skrifa í skjöl.

Ef við höldum áfram með dæmið um klasana sem útfæra write, þá gæti einn þeirra skrifað í skjal á tölvu úti í þýskalandi, einn sendir skjalið í tölvupósti og einn lætur talgervil lesa það upp í strætó leið 14.
Upphaflegi gagnaklasinn veit ekkert um það heldur treystir bara á að fá einhvern hlut í hendurnar sem kann þessa aðferð sama hvernig hún er útfærð.