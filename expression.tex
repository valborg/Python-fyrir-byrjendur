\chapterimage{chapter_head_2.pdf} % Chapter heading image

\chapter{Segðir, skilyrðissetningar og sanngildi}\label{k:segðir}
\todo{laga þessa kynningu}
Kóða má skipta í segðir (e. expressions) og yrðingar (e. statements).
Segðir eru línur þar sem eitthvað er metið sem gildi, ef við líkjum því við tungumál væru það setningar þar sem einhver niðurstaða fæst eins og ,,er rigning''? 
Yrðingar eru línur þar sem eitthvað er sett fram sem þarf ekki að meta, í tungumáli væru það setningar á borð við ,,mér er kalt''

Þessi skipting er ekkert sérlega merkileg að svö stöddu en í þessum kafla ætlum við að einbeita okkur að því að meta útkomu og fá í hendurnar svör sem við getum svo gert eitthvað við.

Til þess að gera það þurfum við að læra á nýja týpu sem heitir Boolean og hefur lykilorðið \textbf{bool}, boolean gildi eru kölluð búlsk gildi eða sanngildi.
Boolean týpan er frábrugðin þeim týpum sem við höfum séð hingað til því að það eru eingöngu tvö möguleg gildi sem Boolean getur verið, \textbf{True} og \textbf{False} sem þýðast sem 1 og 0, satt og ósatt og eru upprunin úr búlískri algebru \footnote{Ekki verður farið yfir búlíska algebru af neinu ráði í þessari bók en þau fræði eru gífurlega góður grunnur til að skilja betur hvernig segðir og rökvirkjar virka og því hvetur höfundur til að lesandi fletti allavega upp wikipedia greininni.} (e. Boolean algebra). 
Nú er það flestum kunnug staðreynd að tölvur vinna með 0 1 í grunninn, en hvernig það er notað í æðri forritunarmálum (e. high level programming languages) er ekki eins augljóst.

Í þessum kafla verður farið yfir búlísk gildi, samanburð (e. comparison) og samanburðarvirkja (e. comparison operators), rökvirkja (e. logical operators) og svo skilyrðissetningar (e. conditional statements).

\section{Sanngildi}\index{Sanngildi}

Eins og kom fram í inngangi kaflans eru búlsk gildi einungis tvö, True og False.
Hægt er að geyma þau í breytum eins og gögn af öðrum týpum sem við höfum séð.
Sanngildi eru einnig metin sem 1 eða 0, fyrir True annars vegar og False hinsevegar.

Vitandi að gildin geta verið 0 eða 1 (aldrei bæði í einu) þá er þess virði að nefna hérna sanntöflur.
Látum p vera yrðinguna ,,það er rigning'' og látum q vera yrðinguna ,,mér er kalt''.
Þá gætum við, með því að skoða mismunandi aðstæður, fengið rökrétt svar við t.d. spurningunni ,,er rigning og er mér kalt?'' sem við getum skrifað sem s1 og svo annarri spurningu sem er ,,er rigning eða er mér kalt?'' sem við getum kallað s2.

\begin{center}
\centering
\begin{table}
	\centering
\caption{Sanntafla}
\vspace{3pt}
\label{tbl:sanntafla}
\begin{tabular}{|c c|c|c|}
	% |c c|c| means that there are three columns in the table and% a vertical bar ’|’ will be printed on the left and right borders,
	% and between the second and the third columns.% The letter ’c’ means the value will be centered within the column,
	% letter ’l’, left-aligned, and ’r’, right-aligned.
	p & q & s1 & s2\\ 
	% Use & to separate the columns
	\hline  
	% Put a horizontal line between the table header and the rest.
	0 & 0 & 0 & 0\\
	0 & 1 & 0 & 1\\
	1 & 0 & 0 & 1\\
	1 & 1 & 1 & 1\\
	\end{tabular}

\end{table}
\end{center}
\todo{laga þetta ótrúlega mikla pláss sem er á milli textans og töflunnar}
Ef við horfum á töflu \ref{tbl:sanntafla} þá sjáum við að yrðingarnar okkar um rigningu og kulda eru uppsettar þannig að hver lína í töflunni er einstakt ástand, og allar mögulegar samsetningar koma fram \footnote{Fjöldi lína í sanntöflu byggir á fjölda yrðinga sem á að skoða. Ef það er bara ein yrðing þá er fjöldi lína 2, það er satt eða ósatt. Fjöldi lína er 2 í veldi fjölda staðhæfinga, eins og í töflu \ref{tbl:sanntafla} þá eru yrðingarnar tvær svo línurnar eru 2², og ef þær væru þrjár þá væri línufjöldinn 2³ og svo framvegis.}.
Báðar yrðingar eru ósannar í fyrstu línunni, svo eru þær sannar sitt á hvað, og í fjórðu línu eru þær báðar sannar.
Þá eru dálkarnir fyrir s1 og s2 svörin við spurningunum hér að ofan miðað við sanngildi yrðinganna í þeim tilteknu aðstæðum.
Í þeim aðstæðum þar sem er hvorki rigning né mér er kalt þá er svarið við báðum spurningum einnig neitandi (0).
Í þeim aðstæðum þar sem er bæði rigning og mér er kalt þá er svarið við báðum spurningum játandi (1).
Þannig að til þess að svarið við spurningu 1 sé játandi þá þarf mér bæði að vera kalt og það þarf að vera rigning, svo þegar yrðingarnar eru ekki sannar á sama tíma þá skiptir ekki máli hvor sé sönn því að önnur er ósönn og því er svarið neitandi.
En spurning 2 er þannig orðuð að það sé nóg að annað hvort sé mér kalt eða það sé rigning úti til þess að svarið sé játandi, svo þegar yrðingarnar eru sannar á víxl þá er svarið alltaf játandi.
\begin{lstlisting}[caption=Sanngildi geymd sem breytur, label=lst:bool-breytur]
test = True
# þetta geymir gögn af týpunni Bool

test = true
# þetta veldur villu þar sem nú er verið að biðja um að test innihaldi það sama og breytan true vísar á
# munurinn er í stóru og litlu t.

test = "True"
# þetta er ekki af týpunni Bool heldur er þetta strengur

test = False
# þetta geymir gögn af týpunni Bool
\end{lstlisting}

Akkúrat núna þurfum við bara að vita að týpan Boolean sé til og hvernig eigi að nota hana, með hástaf fremst.
Sjáum svo í seinni köflum hvernig hún gagnast okkur.


\section{Segðir}\index{Segðir}

Eins og kom fram í inngangi kaflans má líta svo á að segðir séu sá hluti af kóðans sem er metinn sem eitthvað gildi, eins og 4 + 5 er segð en x = 5 er yrðing.
Nú ætlum við þó að einblína á búlskar segðir, það er horfa á spurningar sem hafa svar sem er annað hvort satt eða ósatt.
Er rigning?
Þá horfum við út og sjáum að miðað við aðstæður þá er svarið annað hvort satt eða ósatt og það breytist eftir því hvenær við horfum.

\subsection{Samanburður}\index{Samanurður}
Hvað er samanburður?
Það er þegar eitthvað er metið miðað við eitthvað annað, eins og er þetta stærra en hitt?
Er þetta þyngra?
Er þetta jafngilt?

Nú þurfum við nýtt hugtak, við erum búin að kynnast reiknivirkjum eins og + og - í kafla \ref{k:tolur}.
Nýja hugtakið okkar eru \textbf{samanburðarvirkjar}.
Samanburðarvirkjar eru notaðir til að spyrja hvort að ákveðin tengsl gilda á milli einhverja tveggja hluta.
Eins og í daglegu tali þegar við segjum ,,er þetta epli stærra en þessi appelsína?'' og erum þannig að bera saman epli og appelsínur, samanburðarvirkjar eru til þess að gera slíka setningu formlega svo að tölva geti svarað spurningunni.

Samanburðarvirkjar eru nokkir í Python:
\begin{itemize}
	\item == þá er spurt hvort að hlutirnir sitt hvoru megin við virkjann séu jafngildir
	\item != þá er spurt hvort að hlutirnir sitt hvoru megin við virkjann séu ólíkir
	\item < þá er spurt hvort að það sem er vinstra megin sé strangt minna en það sem hægra megin (3 er ekki minna en 3 t.d.)
	\item > þá er spurt hvort að það sem er vinstra megin sé strangt stærra en það sem er hægra megin
	\item <= þá er spurt hvort að það sem er vinstra megin sé minna eða jafnt því sem er hægra megin
	\item >= þá er spurt hvort að það sem er vinstra megin sé stærra eða jafnt því sem er hægra megin
\end{itemize}

Skoðum kóðabút þar sem þessir samanburðarvirkjar eru nýttir til þess annars vegar að fá niðurstöður með tölur og hinsvegar strengi.
\begin{lstlisting}[caption=Samanburðarvirkjar, label=lst:bool-samanburður]
# nú viljum bera saman einhver gögn, búum okkur til breytur til að bera saman
strengur1 = "abc"
strengur2 = "bcd"
strengur3 = "3"
tala1 = 3
tala2 = 3.0
tala3 = 4

# nú erum við komin með nokkrar breytur til að gera prófanir á:

# byrjum á að skoða hvort að 3 sé jafngilt 4 eða tveir jafnlangir strengir séu jafngildir
tala1 == tala3 
# þetta skilar False

strengur1 == strengur2
# þetta skilar False

# en hvað með þetta?
tala1 == tala2
# þetta skilar True þar sem til að geta borið talnatýpur saman er þeim kastað í sambærileg gögn (skoðum kast í seinna í kaflanum)

strengur3 == tala1 
# þetta skilar False þar sem ekki er verið að vinna með eingöngu gögn af talnatýpum

# Allt það sem skilar okkur True með == skilar okkur False með != 
# og öfugt, það sem skilar False með == skilar okkur True með !=

# skoðum þá minna en og stærra en

strengur1 < strengur2
# þetta skilar okkur True þar sem strengur1 er framar í stafrófinu, ekki er verið að bera saman lengdina á strengjunum

tala1 < tala2
# þetta skilar okkur False þar sem tölurnar eru jafngildar, sáum það að hér að ofan, og önnur getur ekki verið bæði minni og jöfn á sama tíma

tala1 <= tala2
# þetta skilar okkur True þar sem spurt er hvort að tala1 sé annað hvort minni en eða jöfn hinni breytunni

# Það skiptir máli hvernig goggarnir snúa, a > b hér er spurt hvort a sé stærra en b, b < a, hér er spurt hvort b sé minna en a (sem er sama spurningin).
\end{lstlisting}

\subsection{Rökvirkjar}\index{Rökvirkjar}
Rökvirkjar (e. logical operators) í Python eru þrír, þeir eru \textbf{og}, \textbf{eða}  og \textbf{ekki} táknað með \texttt{and}, \texttt{or} og \texttt{not}.
Nöfnin þeirra eru lykilorð í Python eins og nöfnin á týpunum sem við höfum séð (\textbf{str}, \textbf{int}, \textbf{float}, \textbf{list}) en rökvirkjar eru ekki gögn af einhverri týpu heldur eru meira eins og reiknivirkjarnir (+, -, *, **, //, \%).
Það sem þessir virkjar gera fyrir okkur er að taka tvær búlskar segðir og egja okkur eitthvað um samsetningu þeirra.
Tökum dæmi; ,,Kaffið er heitt og það eru til sítrónur.'' 
Hægt er að meta hvort að kaffið sé heitt eða ekki, og fá þannig út sanngildi fyrir þá segð, það er hægt að gera það sama fyrir segðina um sítrónurnar.
En tökum eftir að á milli þessara tveggja segða er rökvirkinn \textit{og}, sem segir okkur að til þess að meta gildi allrar setningarinnar þurfa báðar segðirnar sitthvoru megin við rökvirkjann að vera sannar til þess að setningin í heild sinni skili sönnu annars er hún ósönn.
\vspace{10pt}
\begin{itemize}
	\item \textbf{and} til þess að segð með þessum rökvirkja sé sönn þurfa báðar hliðar að vera sannar, annars er hún ósönn
	\begin{itemize}
		\item Það má líta á \textit{og} rökvirkjann eins og margföldun, hann hefur forgang umfram \underline{eða}.
		\item Þar sem satt er 1 og ósatt 0 þá ef við margöldum með 0 fáum við alltaf 0 út.
		\item ,,það er heitt úti'' og ,,það er kalt úti'' myndi skila okkur ósönnu því ekki getur bæði verið satt.
		\item ,,það er heitt úti'' og ,,klukkan er fimm'' myndi skila okkur sönnu eftir aðstæðum.
	\end{itemize}
	\item \textbf{or} til þess að segð með þessum rökvirkja sé sönn þarf önnur hvor hliðin að vera sönn, annars er hún ósönn.
	\begin{itemize}
		\item Það má líta á \textit{eða} rökvirkjann eins og samlagningu.
		\item Þar sem satt er 1 og ósatt 0, þá þurfum við bara að sjá 1 einu sinni til þess að útkoman í heild sinni verði sönn.
		\item ,,það er heitt úti'' eða ,,það er kalt úti'' myndi skila okkur sönnu ef þetta væru þau einu tvö hitastig sem væru í boði.
		\item ,,það er heitt úti'' eða ,,klukkan er fimm'' myndi skila sönnu eftir aðstæðum.
	\end{itemize}
	\item \textbf{not} snýr við sanngildi segðar, not er ekki sett á milli segða heldur fyrir framan eins segð.
	\begin{itemize}
		\item Það má líta á rökvirkjan \textit{ekki} eins og mínus, hann snýr við sanngildi eins og formerki
		\item Ekki satt yrði ósatt, ekki ósatt yrði satt.
		\item \textbf{ekki} ,,það er heitt úti'' yrði að yrðingunni ,,það er ekki heitt úti''.
	\end{itemize}
\end{itemize}

\vspace{5pt}
\todo{formatting}
\begin{itarefni}
\textbf{Rökvirkjar sem reikniaðgerðir}\\
Til að halda áfram með þessa samlíkingu með margföldun, samlagningu og mínus skulum við skoða eftirfarandi reikningsdæmi:
1$\cdot$1$\cdot$1$\cdot$0 + 1$\cdot$0 + (-1).
Hér gerum við ráð fyrir að hver hluti af þessu reikningsdæmi sé yrðing sem búið er að meta sem sanna eða ósanna eftir þeim aðstæðum sem við erum í (kaffið er heitt, það er kalt úti og þess háttar).
Þegar við reiknum þetta dæmi sjáum við að margfaldað er með 0 í báðum þáttunum þar sem margföldun kemur fyrir svo útkoman í hvorum fyrir sig ætti að vera núll.
Þessi síðasti liður er okkur ekki eins eðlislægur en við munum að það eru bara til 0 eða 1 og mínus skiptir gildinu okkar svo við hljótum að enda með 0.
Þannig að við endum í 0 + 0 + 0 sem gefur okkur 0 og því er öll segðin metin sem ósönn.
\end{itarefni}


\section{Skilyrðissetningar}\index{Skilyrðissetningar}
Nú viljum við vita til hvers í ósköpunum við vorum eiginlega að leggja það á okkur að skilja hvenær eitthvað er satt eða ósatt.
Það er einmitt heilmikið tölvunarfræðilegt gagn í því að geta spurt svona já eða nei spurninga sem tölvan getur svarað.
Til dæmis viljum við geta framkvæmt einhverja aðgerð í forritinu okkar \textbf{ef} einhver skilyrði eru fyrir hendi.
Segjum að við séum með vekjaraklukku sem við forritum til að hringja þegar klukkan er orðin 8.
Þá viljum við geta spurt tölvuna hvort að það sé satt eða ósatt að klukkan sé orðin 8.
Ef klukkan er ekki orðin 8 viljum við ekki gera neitt, en ef hún er orðin átta þá viljum við að hún spili einhvern hljóm eða titri.
Við gætum líka verið að forrita einfaldan tölvuleik eins og hengimann, ef spilarinn er ekki búinn að giska á alla stafina í orðinu okkar viljum við geta beðið viðkomandi að spyrja aftur.
\textbf{Annars} viljum við að notandinn fái verðlaun fyrir að hafa giskað á rétt orð \footnote{Hérna er gert ráð fyrir að mega giska óendanlega oft rangt.}.
Einnig gætum við viljað gera eitthvað tiltekið þá og því aðeins að eitthvað annað var ósatt.
Ef við notum okkar eigin máltilfinningu til að leggja skilning í eftirfarandi setningu: Ef við eigum ekki mjólk vil ég kaupa mjólk, ef svo er ekki vil ég athuga hvort að við eigum kex og ef við eigum ekki kex vil ég kaupa það, annars fer ég ekkert í búðina.
Hér er aðaláherslan lögð á mjólkurstöðuna okkar, ef við eigum ekki mjólk viljum við laga það, en ef við eigum mjólk þá getum við gert eitthvað annað.

Þarna eru komnar aðstæður þar sem við athugum mólkurstöðuna og fyllum á ef þarf, en ef við eigum nóg af mjólk þá viljum við samt athuga hvort að við eigum nóg af safa því að við gætum þurft að fylla á þar.
Hér er kannski ekki augljóst en ef það vantar mjólk þá skiptir ekki máli hvort það vanti kex eða ekki, við förum í búðina og kaupum mjólk, við kaupum ekki kex.
Þetta skilst kannski frekar á flæðiriti sem sést á mynd \ref{fig:flæðirit}.
Flæðiritið líkir eftir uppsetningu á skilyrðissetningum þannig að það sem er inni í gænum þríhyrningum eru spurningar sem þarf að svara, bláu ferhyrningarnir eru svo niðurstöður sem fást í málið.

\tikzstyle{startstop} = [rectangle, rounded corners, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=red!30]
\tikzstyle{io} = [trapezium, trapezium left angle=70, trapezium right angle=110, minimum width=2cm, minimum height=1cm, text centered, draw=black, fill=blue!30]
\tikzstyle{process} = [rectangle, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=blue!30]
\tikzstyle{decision} = [diamond, minimum width=3cm, minimum height=3cm, text centered, draw=black, fill=green!30]
\tikzstyle{arrow} = [thick,->,>=stealth]

\vspace{5pt}
\begin{figure}[H]
	\centering
\begin{tikzpicture}[node distance=2cm]
\node (mjolk) [decision] {Engin mjólk};
\node (kex) [decision, below of=mjolk, yshift=-1.5cm] {Ekkert kex};
\node (bud1) [process, right of=mjolk, xshift=3cm] {Kaupa mjólk};
\node (bud2) [process, right of=kex, xshift=3cm] {Kaupa kex};
\node (bud3) [process, below of=kex, yshift=-0.5cm] {Vera heima};
\draw [arrow] (mjolk) -- node[anchor=west] {ósatt} (kex);
\draw [arrow] (mjolk) -- node[anchor=south] {satt} (bud1);
\draw [arrow] (kex) -- node[anchor=south] {satt} (bud2);
\draw [arrow] (kex) -- node[anchor=west] {ósatt} (bud3);
\end{tikzpicture}
\caption{Hér sést hvernig setningin: ,,Ef við eigum ekki mjólk vil ég kaupa mjólk, ef svo er ekki vil ég athuga hvort að við eigum kex og ef við eigum ekki kex vil ég kaupa það, annars fer ég ekkert í búðina.'' má setja fram sem fæðirit. Ef það er engin mjólk þá förum við og kaupum mjólk, en ef það er til mjólk þá athugum við hvort að það sé til kex og kaupum það ef það vantar, hins vegar ef við eigum bæði kex og mjólk er engin ástæða til að fara í búðina.}
\label{fig:flæðirit}
\end{figure}

\vspace{5pt}

Vegna þess að áherslan er lögð á ,,við eigum ekki mjólk'' þá er vitlegast að setja inn segð sem er með neitun.
Ef yrðingin m stendur fyrir setninguna ,, við eigum mjólk'' þá er yrðingin ekki m (not m) ,,við eigum ekki mjólk''.
Skoðum þetta í töflu \ref{tbl:sanntafla-kaffi}, sambærilegri þeirri sem við sáum áður (tafla \ref{tbl:sanntafla}), nema í staðinn fyrir p og q notum við yrðinguna ,,það er til mjólk''.
\begin{center}
	\centering
	\begin{table}[H]
		\centering
		\caption{Sanntafla með ákveðnum yrðingum}
		\vspace{3pt}
		\label{tbl:sanntafla-kaffi}
		\begin{tabular}{|c | c| c |}
			% |c c|c| means that there are three columns in the table and% a vertical bar ’|’ will be printed on the left and right borders,
			% and between the second and the third columns.% The letter ’c’ means the value will be centered within the column,
			% letter ’l’, left-aligned, and ’r’, right-aligned.
			m = það er til mjólk & ekki m = það er ekki til mjólk\\ 
			% Use & to separate the columns
			\hline  
			% Put a horizontal line between the table header and the rest.
			0 & 0 & Bæði ósatt, gengur ekki upp\\
			0 & 1 &\\
			1 & 0 &\\
			1 & 1 & Bæði satt á sama tíma, gengur ekki upp\\
			\hline
		\end{tabular}
		
	\end{table}
\end{center}
Við viljum að aðalatriðið komi fram í inngangspunktinum í skilyrðissetningunni okkar til að hún sé skýrt upp sett og skiljanleg, til þess gætum við þurft að nota neitun.
Við sjáum betur í næstu þremur undirköflum hvað ætti að fara á hvaða stað, en eins og með góðar nafnavenjur þegar við nefnum breyturnar okkar skulum við venja okkur á strax í upphafi að skilyrðissetningarnar okkar eru skýrar.

Nú höfum við séð í inngangi þessa undirkafla orðunum ef og annars slengt fram.
Við þekkjum þessi orð og skiljum hvernig á að nota þau í setningu til að kalla fram útkomu.
En það sem við þurfum að gera núna er að átta okkur á því að þessi orð eru mun formlegri í forritun heldur en í daglegu tali.
Eins og til dæmis: ,,Ertu ekki að hugsa um Jamie Lee Curtis?''
Í íslensku er hægt að svara þessari spurningu með ,,já ég er ekki að hugsa um hana'' eða ,,nei ég er ekki að hugsa um hana'' og bæði skilst, einnig er hægt að segja ,,jú ég er að hugsa um hana''.
Forritunarmál eru ekki tungumál, þau eru formleg og því er engin tvíræðni í boði.

Skoðum því nú hvað það þýðir að nota skilyrðissetningar (e. conditional statements) í Python með lykilorðunum \textbf{if - elif - else}, sem verða þó kynnt annarri röð.

\subsection{if}\index{if}
Fyrsta lykilorðið sem við tökum fyrir er \textbf{if}, þar sem ekki er hægt að búa til skilyrðissetningu án þess.
Og nú þurfum við að huga að því hvernig kóðinn okkar er uppsettur.
Það sem á að framkvæma undir ef setningunni/if yrðingunni er inndregið um fjögur bil eða einu sinni á ,,tab'' takkann \todo{íslenskt orð}.
Eina sem ræður því hvað fer mikið af kóða undir hverja yrðingu er hóf og skynsemi.
Við sjáum svo í kafla \ref{uk:hreiðrun} um hreiðrun hvers vegna það er mikilvægt að skilyrðissetningar séu skýrar.

Góð venja er að búa til skilyrðissetningar þar sem aðalvirknin á sér stað inni í if yrðingunni, þannig að segðin sem fer þar inn passi við hvað eigi að framkvæma.
Ef við tökum aftur dæmið um mjólkina og búðarferðina í mynd \ref{fig:flæðirit} og skoðum hvernig flæðiritið breytist eftir því hvernig við orðum skilyrðin.
Það er að við skoðum hvernig uppsetningin á flæðiritinu verður bjöguð ef við orðum spurninguna með játun en ekki neitun: Ef það er til mjólk vil ég athuga hvort það sé til kex ef svo er vil ég vera heima, annars kaupi ég kex ef það er til mjólk en ekki kex og annars kaupi ég mjólk ef það er ekki til mjólk.
Þetta er kannski ekki nógu flókin setning til þess að valda þeim hugrhrifum sem ætlast er til, en við sjáum að til þess að komast að þeim endapunkti sem aðaláherslan er á ,,vera heima'' þar sem hún er fyrsti endapunkturinn okkar þá þurfum við að fara í gegnum tvær spurningar.
Svo með því að orða spurninguna öðruvísi erum við búin að setja upp skilyrðissetninguna upp þannig að mólkurstaðan er núna ekki lengur í forgrunni, við virðumst frekar vera að reyna að halda okkur heima.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[node distance=2cm]
	\node (mjolk) [decision] {Mjólk er til};
	\node (kex) [decision, right of=mjolk, xshift=2cm] {Kex er til};
	\node (bud1) [process, below of=mjolk, yshift=-4cm] {Kaupa mjólk};
	\node (bud2) [process, below of=kex, yshift=-2cm] {Kaupa kex};
	\node (bud3) [process, right of=kex, xshift=2cm] {Vera heima};
	\draw [arrow] (mjolk) -- node[anchor=south] {satt} (kex);
	\draw [arrow] (mjolk) -- node[anchor=west] {ósatt} (bud1);
	\draw [arrow] (kex) -- node[anchor=west] {ósatt} (bud2);
	\draw [arrow] (kex) -- node[anchor=south] {satt} (bud3);
	\end{tikzpicture}
	\caption{Hér sést hvernig setningin: ,,Ef það er til mjólk vil ég athuga hvort það sé til kex ef svo er vil ég vera heima, annars kaupi ég kex ef það er til mjólk en ekki kex og annars kaupi ég mjólk ef það er ekki til mjólk.'' má setja fram sem fæðirit.
	Þetta veldur því að aðaláherslan virðist nú vera að komast að því hvort eigi að kaupa kex eða vera heima og mjólkurstaðan er athuguð fyrst af einhverri ástæðu.
	Setningin í heild er frekar ruglingsleg og hún kom mun betur út í flæðiritinu á mynd \ref{fig:flæðirit}.
	Þó áherslan sé önnur er niðurstaðan sú sama, það er á ábyrgð forritara að skrifa kóða sem er læsilegur og skiljanlegur.}
	\label{fig:flæðirit-neitun}
\end{figure}

Skoðum nú kóðabút \ref{lst:if} og hvað er átt við með réttum inndrætti, hér er einungis sýnt if setning ein og stök.
Við sjáum í næsta undirkafla hvað við getum gert ef við förum framhjá if setningunni okkar og viljum gera eitthvað í því tilfelli.

\begin{lstlisting}[caption=if notað, label=lst:if]
m = True # m er yrðingin hvort að til sé mjólk eða ekki, við gefum okkur í upphafi að til sé mjólk því er m upphafsstillt sem True

if(not m):
	# fara í búð
	print('við fórum í búðina og keyptum mjólk')
	
	# Við áttum mjólk svo þetta prentast ekki, við förum framhjá aðgerðunum sem eru undir if skipuninni
\end{lstlisting}

\subsection{else}\index{else}
Lykilorðið \textbf{else} má fylgja \textbf{if}, en það er ekki nauðsynlegt.
Hinsvegar verður að vera eitthvað ef til þess að það geti verið eitthvað annars.
Setningin ,,annars kaupi ég mjólk'' er ekki sérlega vitræn því að okkur vantar alveg fyrri hlutann.
Einnig er ekki sérlega vitrænt að segja ,,ég kaupi mjólk ef vantar annars kaupi ég kex annars kaupi ég te annars...''.
Því er einungis hægt að setja eitt annars við hvert ef, sjáum kóðabút \ref{lst:else}.
Sú klausa keyrist einungis þegar ef setningin sem hún hangir fyrir neðan keyrist ekki, og það eru einu skilyrðin.
Það þarf ekki að spyrja neinnar spurningar sem er metið sem boolean gildi til að keyra else, það mun alltaf keyrast þegar segðin í ef yrðingunni var ósönn.

\begin{lstlisting}[caption=else notað, label=lst:else]
m = True # m er yrðingin hvort að til sé mjólk eða ekki, við gefum okkur í upphafi að til sé mjólk því er m upphafsstillt sem True

if(not m):
	# fara í búð
	print('við fórum í búðina og keyptum mjólk')
else:
	# takið eftir að hér var ekkert skilyrði athugað
	# við förum hingað inn ef skilyrðið fyrir ofan var ekki keyrt
	print('vera heima')

# Við áttum mjólk svo við fáum út 'vera heima'

if(3 < 4):
	print("þrír er minna en fjórir")
else:
	print('ég fer ekki hingað inn, því 3 er vissulega minna en fjórir, en það er gott að vera við öllu búin')
\end{lstlisting}

Að geta sett svona annars-klausu er mikilvægt því að við viljum geta brugðist við ef upphaflega skilyrðið okkar er ósatt.
Við viljum geta tekið á öðrum tilfellum heldur en bara upphafsskilyrðinu okkar.

\subsection{elif}\index{elif}
En hvað ef við viljum geta tekið á einhverju sérstöku tilfelli, sem kemur einungis upp í ákveðnum aðstæðum?
Við viljum ekki bara grípa það að inngangspunkturinn okkar var ósannur heldur viljum við einnig skoða eitthvað fleira?
Þarna kemur setningin um mjólkina, kexið og búðarferðirnar aftur inn.
Þá getum við sagt ,,ef það er ekki til mjólk, fer ég í búð, \textbf{annars ef} það er ekki til kex fer ég í búð og kaupi kex, nú annars er engin ástæða til að fara í búðina og ég verð bara heima''.
Sjáum þetta forritað í kóðabút \ref{lst:elif}.

Skilyrðissetningar eru settar upp þannig að það verður að vera eitt \textbf{if} svo mega koma núll eða fleiri \textbf{elif} og að lokum má setja 0 eða 1 \textbf{else}.
Þetta er eins og málfræðilegur skilningur okkar er á tungumálinu, við megum hengja endalaust af annars ef klausum inn í setningarnar okkar, þær verða þá bara erfiðari að skilja.

\begin{lstlisting}[caption=elif notað, label=lst:elif]
m = True # m er yrðingin hvort að til sé mjólk eða ekki, við gefum okkur í upphafi að til sé mjólk því er m upphafsstillt sem True
k = False # k er yrðingin hvort að til sé kex eða ekki, við gefum okkar að í upphafi sé ekki til neitt kex og k er því False


if(not m):
	# fara í búð
	print('við fórum í búðina og keyptum mjólk')
elif(not k):
	# keyrist ef not m var metið sem False OG not k metið sem True
	print('við fórum í búðina og keyptum kex')
else:
	# takið eftir að hér var ekkert skilyrði athugað
	# við förum hingað inn ef skilyrðið fyrir ofan var ekki keyrt
	# tökum eftir að það skilyrði er nú elif setningin okkar
	print('vera heima')

# Við áttum mjólk en við áttum ekki kex, svo not k var metið sem True og við fáum svo við fáum 'við fórum í búðina og keyptum kex'

# Við förum ekki niður í else nema að allt fyrir ofan sé ósatt.

if(5 < 4):
	print("fimm er minna en fjórir")
elif(4 < 4):
	print("fjórir er minna en fjórir!")
elif(3 < 4):
	print("þrír er minna en fjórir")
elif(2 < 4):
	print("þetta prentast ekki því að ég get bara farið inn í eina klausu í hverri skilyrðissetningu")
	print("og það gerðist hérna fyrir ofan, svo þetta skilyrði verður ekki keyrt")
else:
	print('ég fer ekki hingað inn, því 3 er vissulega minna en fjórir, en það er gott að vera við öllu búin')
\end{lstlisting}

\subsection{Hreiðrun}\index{Hreiðrun}\label{uk:hreiðrun}
Hreiðrun (e. nesting) þýðir að setja endurtekið undir eitthvað annað, eins og babúska dúkkur eða að pakka gjöf inn í mörg lög af gjafapappír.
Í forritun þýðir hreiðrun að yrðing af einhverri tegund tilheyri og sé keyrð innan í yrðingu af sömu tegund.
Við getum hugsað þetta í samhengi við skilyrðissetningar að við séum með innri skilyrðissetningar sem þarf einnig að meta til þess að komast að niðurstöðu.
Skoðum þetta aftur í samhengi við mjólkurkaupin nema nú bætum við því við að við eigum bara ákveðið mikinn pening sjá kóðabút \ref{lst:nesting}.

\begin{lstlisting}[caption=Hreiðrun, label=lst:nesting]
m = True # m er yrðingin hvort að til sé mjólk eða ekki, við gefum okkur í upphafi að til sé mjólk því er m upphafsstillt sem True
k = False # k er yrðingin hvort að til sé kex eða ekki, við gefum okkar að í upphafi sé ekki til neitt kex og k er því False
p = 100 # p eru hversu mikinn pening við erum við á okkur.

if(not m):
	# fara í búð, ef við komumst hingað inn þá var m False og not m var þá True
	# nú sjáum við hvað þarf að gerast til þess að við getum keypt mjólkina ef við komumst hingað inn
	if(p > 200):
		print('við fórum í búðina og keyptum mjólk því við vorum með nógu mikinn pening')
	else:
		print('okkur vantaði mjólk en við vorum ekki með nógu mikinn pening')
elif(not k):
	# keyrist ef not m var metið sem False OG not k metið sem True
	if(p > 99):
		print('við fórum í búðina og keyptum kex því við vorum með nægan pening')
	else:
		print('okkur vantaði kex en við vorum ekki með nægan pening')
else:
	# takið eftir að hér var ekkert skilyrði athugað
	# við förum hingað inn ef skilyrðið fyrir ofan var ekki keyrt
	# tökum eftir að það skilyrði er nú elif setningin okkar
	print('vera heima og geyma allan peninginn')

# Við áttum mjólk sem var heppilegt, því að við hefðum ekki getað keypt hana
# Við áttum ekki kex, og svo heppilega vildi til að við vorum með nóg fyrir kexpakka og því fáum við niðurstöðuna:
# 'við fórum í búðina og keyptum kex því við vorum með nægan pening'
\end{lstlisting}

Hreiðrun er gagnleg því að við viljum skoða eitthvað innra skilyrði aðeins ef ytra skilyrðinu er mætt.

\section{Inntak}\index{Inntak}
Nú höfum við verið að skoða spurningar og svör við þeim sem við skráðum sjálf.
Það sem við viljum geta gert er að spyrja notandann að einhverju og geta gert eitthvað byggt á því svari.
Við þurfum að fá inntak (e. input) frá notandanum.

Þá lærum við um nýtt innbyggt fall í Python sem heitir \texttt{input()}.
Það sem input() gerir er að það tekur við streng sem það birtir á úttaki (e. output) þar sem notandinn sér það og getur sett eitthvað inn.
\todo{er ég ekki búin að tala um output?}
Að nota input() í skipanalínu gefur okkur nýja línu til að svara, að nota input() í Jupyter Notebooks gefur okkur lítinn glugga til að skrifa svarið okkar í fyrir neðan selluna þar sem input() skipunin er keyrð.
Skoðum kóðadæmi í kóðabút \ref{lst:input}, þar sem við geymum svarið frá notanda í breytu og viðfangið sem við setjum inn í fallið er strengur sem inniheldur spurninguna sem notandinn sér.
Vert er að athuga að allt sem er sett inn sem svar í þennan glugga er kastað í streng, það er breytan sem við notum til að taka á móti því sem input() fallið skilar er af týpunni strengur.
Ef við viljum geta spurt notandann um tölustafi þurfum við að kunna að kasta á milli gagnataga sjálf og við sjáum hvernig það er gert í kóðabút \ref{lst:kast}


\begin{lstlisting}[caption=input() fallið notað, label=lst:input]
svar = input('skrifaðu nafnið þitt')

# hér birtist gluggi fyrir okkur til að skrifa eitthvað inn í sem er merktur sem 'skrifaðu nafnið þitt'
# ég skrifa nafnið mitt og ýti á vendibil (e. enter) takkann og þá er svarið mitt komið í breytuna svar

print('halló', svar, 'mikið heitir þú fallegu nafni')

# Fyrir inntakið Valborg myndi nú prentast:
# 'halló Valborg mikið heitir þú fallegu nafni'
\end{lstlisting}

Þetta er mikilvægt fall fyrir okkur að skilja og nota á þessu stigi málsins, því að við verðum að átta okkur á því að þegar við forritum þá erum við miklu meira að vinna með breytunöfn heldur en gögn sem við getum horft á.
Í kóðabút \ref{lst:input} þá kemur hvergi fram í kóðanum að nafnið sé Valborg, og það getur verið hvað sem er, við prentum bara út það sem notandinn gaf okkur án þess að vera eitthvað að skoða hvað það er.
Oft vilja byrjendur horfa á gögnin sín og setja inn niðurstöður fyrir tölvuna, til dæmis verkefnið ,,búðu til breytu sem inniheldur nafn og prentaðu út breytuna ásamt strengnum "halló:"'' endar í kóða eins og sést í kóðabút \ref{lst:byrjendur}

\begin{lstlisting}[caption=Oft forðast byrjendur að nota breytur og treysta meira á að sjá hvað ætti að koma út, label=lst:byrjendur]
# Búðu til breytu sem inniheldur nafnið þitt:
nafn = 'Valborg'
# prentaðu hana út ásamt "halló:"
print('Halló: Valborg') # hér er ekkert verið að nota breytuna nafn heldur horfir forritarinn á kóðann og sér að tölvan eigi að prenta út 'Valborg' og setur það inn handvirkt.

# Annað dæmi væri að finna tákn sem er í miðjum streng
strengur = "þessi strengur hefur 29 tákn!"
# miðjan í þeim streng er því í tákni 14 sem tölvan getur náð í með len(strengur)//2
# og getur því fundið miðjutáknið með 
strengur[len(strengur)//2] # skilar okkur tákninu í vísi 14

# en hér er einnig hægt að taka nokkur skref sem er algengt að byrjendur geri
print(len(strengur)) # þetta skilar okkur 29
print(29/2) # þetta skilar okkur 14.5 eða print(29//2) sem skilar 14
print(strengur[14]) # þetta skilar okkur tákninu í miðjunni

\end{lstlisting}

Eins og sést í kóðabút \ref{lst:byrjendur} að til að komast að því að setja vísi 14 inn og fá táknið þarf að keyra fyrst línuna len(strengur) til þess að sjá þá tölu og svo þarf að deila þeirra tölu með tveimur til að finna miðjuna og svo þarf handvirkt að setja þá tölu inn eftir að hafa breytt henni í næstu heilu tölu.
Það sem er að gerast er ekkert rangt, það er hinsvegar mikil vannýting á því sem tölvan getur gert fyrir okkur og eykur vinnuna fyrir okkur sjálf umtalsvert því að það þarf að keyra hvert skref í kóðabútnum fyrir sig til að komast að því hvað eigi að gera í næsta skrefi, í stað þess að gera það í einni línu eins og í línu 10.

\subsection{Kastað á milli gagnataga}
Til þess að geta unnið með gögn eins og þá týpu sem við viljum þurfum við að læra að kasta á milli taga/týpna (e. typecasting).
Þetta þýðir að við látum vélina umrita gögnin okkar yfir í annað gagnatag, sem er einungis hægt ef að gögnin eru sambærileg týpunni sem á að kasta í.

Þá koma lykilorðin sem við höfum lært fyrir týpurnar okkar að gagni.
Við þekkjum núna strengi með lykilorðið \textbf{str}, heiltölur með lykilorðið \textbf{int}, fleytitölur með lykilorðið \textbf{float} og lista með lykilorðið \textbf{list}.
Þá notum við lykilorðið eins og fall og setjum inn í fallið sem viðfang það sem á að verða að því gagnatagi sem lykilorðið segir til um.
Sjáum í kóðabút \ref{lst:kast} hvernig á að fara að þessu.

Nú höfum við séð að input() fallið skilar alltaf til okkur gögnum af taginu/týpunni strengur.
En við viljum geta kannski unnið með inntakið frá notandanum sem tölu.
Ef að strengurinn inniheldur einungis tölur á bilinu 0-9 er hægt að geyma hann sem heiltölu eða fleytitölu, ef hann inniheldur einungis tölur á bilinu 0-9 og nákvæmlega einn punkt er hægt að geyma hann sem fleytitölu.


\begin{lstlisting}[caption=Hvernig á að kasta á milli gagnataga, label=lst:kast]
# Þessi strengur inniheldur bara tölur
talnastrengur = "123"

# og því má kasta honum í heiltölu eða fleytitölu
int(talnastrengur)
# þetta skilar okkur tölunni 123

float(talnastrengur)
# þetta skilar okkur tölunni 123.0

fleytitolustrengur = "123.0"

float(fleytitolustrengur) 
# þetta skilar okkur tölunni 123.0

int(fleytitolustrengur)
# þetta skilar okkur villu því að heiltölur eru ekki með punkti þó að þetta sé í grunninn sama tala og 123

# Nánast öllu má svo kasta í streng, þá er hverju tákni úthlutað sætisvísi og geymt eins og það er skrifað.
str(123)
# þetta skilar okkur "123"

str([1,2,3])
# þetta skilar okkur "[1,2,3]"

# Það sem gerist þegar við köstum í lista er að hverju ítranlegum hluta af gögnum er varpað í stak í listanum
# Skoðum betur í kafla um lykkjur hvað ítranlegt þýðir.

list("123.0")
# þetta skilar okkur ["1", "2", "3", ".", "0"]

list(123.0)
# Þetta skilar okkur villu því að tölur eru ekki ítranlegar, þær hafa ekki sætisnúmer (ekki eins og tölvan skilgreinir þau). 
\end{lstlisting}

Nú þar sem við vitum að við getum fengið streng í hendurnar frá notanda, vitandi það að við báðum um tölu, getum við leyft okkur að kasta strengnum í það talnatag sem okkur hentar.
Við sjáum svo í seinni hluta bókarinnar hvernig á að taka á mismunandi tilfellum og reyna á eitthvað sem gæti valdið villu án þess að það skemmi fyrir okkur, en núna ætlum við að láta sem að við getum treyst notendum til að gefa okkur inntak sem samræmist því sem við báðum um. \todo{vísa í kafla um try except}

Ástæðan fyrir því að vilja kasta á milli taga er til að geta beitt þeim aðgerðum og aðferðum sem eru í boði fyrir það gagnatag sem við sækjumst eftir að nota, til dæmis er ekki hægt að sækja þriðja tölustafinn í heiltölu en ef við köstum henni í streng getum við sótt táknið í sætisnúmeri 2 og fengið þannig þriðja tölustafinn.

\begin{itarefni}
\textbf{Dæmi um notkun á kasti milli taga}\\
Seinna munum við sjá gagnatýpuna mengi, ein gagnleg notkun á kasti milli taga væri að kasta lista í mengi til að losna við tvítekningar og kasta menginu svo í lista aftur.\\
\texttt{a = [1, 2, 2]}\\
\texttt{b = set(a)}\\
\texttt{a = list(b)}\\
Nú er listinn \texttt{a} orðinn að \texttt{[1,2]}, sjá meira um það í kafla \ref{k:sett}.
\end{itarefni}
