
\chapter{Tölur og breytur}\index{Tölur og breytur}\label{k:tolur}
Í þessum kafla ætlum við að hefjast handa við að forrita. 
Það fyrsta sem við ætlum að gera er að kynnast talnatýpum og keyra kóða eins og við værum að nota reiknivél. 
Við könnumst við reiknivélar og hvernig þær afgreiða röð aðgerða. 
Nú viljum við sannreyna að þær reikniaðgerðir sem við þekkjum séu til í Python og að þegar við keyrum kóðann okkar þá verði útkoman sú sama og við áttum von á. 
Við viljum líka geta geymt útkomuna okkar til að nota aftur seinna, til þess þurfum við breytur (e. variables).

\section{Tölur - talnatýpur}\index{Tölur - talnatýpur}
Í Pyhton eru í grunninn tvær týpur af tölum (en til eru tvær týpur af hvorri fyrir sig, sem snýr meira að minnisnotkun og er út fyrir svið þessarar bókar). 
Þær eru:

\begin{itemize}
	\item \textbf{Heiltölur} - tölur sem eru ekki með neinum aukastaf. 
	Á ensku eru þessar tölur kallaðar integers og er lykilorð þeirra því \textbf{int}.
	\item \textbf{Fleytitölur} - tölur sem eru með aukastaf, sem er fyrir aftan punkt (ekki kommu, fleytitölur eru oft kallaðar kommutölur á íslensku). 
	Á ensku eru þessar tölur kallaðar floating point numbers og er því lykilorðið þeirra \textbf{float}.
\end{itemize}

\begin{lstlisting}[caption=Heiltölur og fleytitölur]
# Heiltölur, enginn aukastafur
42
100000
-139

# Fleytitölur, aukastafur/ir fyrir aftan punkt
4.0
3.1415926
-100.98
\end{lstlisting}

\section{Reikniaðgerðir og tákn}\index{Reikniaðgerðir og tákn}
Grunnreikniaðgerðir eru nokkrar sem við könnumst við úr grunnskóla en aðrar eru framandi og við skulum skoða aðeins betur.

Táknin eru flest eins og á reiknivélum +, -, *, / en þar að auki er annars konar deiling sem er táknuð með tveimur deilimerkjum //, veldishafning er táknuð með tveimur margföldunarmerkjum **, og svo er leifareikningur táknaður með \%.
Heiltöludeiling og leifarreikningur eru líklega ný á nálinni fyrir flestum lesendum og því allt í lagi að útskýra þær aðgerðir aðeins nánar.
Þessar aðgerðir eru einmitt mjög skyldar í raun.
Deilingin segir okkur hversu oft ein tala gengur upp í aðra þar sem útkoman er heil tala (eða fleytitala með 0 sem eina aukastafinn), okkur er sama um afganginn sem verður eftir.
Í þessari deilingu er svarið 2 við bæði 5//2 og 4//2.
En í leifareikningnum viljum við eingöngu vita hver er afgangurinn þegar heiltöludeilingu er beitt svo 5\%2 væri 1, því það er einn í afgang þegar fimm er deilt með tveimur.
Og það er 0 í afgang þegar fjórum er deilt með tveimur svo 4\%2 er 0.

Í eftirfarandi dæmum í kóðabút \ref{lst:reiknadg} er vert að draga fram nokkur atriði sem eru ekki augljós byrjanda. 
Það fyrsta er að myllumerkið (\#) þýðir að allt sem kemur fyrir aftan það er \textit{athugasemd}, athugasemdir eru engöngu til að gera kóða læsilegri fyrir fólk, þær eru hunsaðar af tölvunni þegar hún breytir kóðanum í eitthvað sem hún skilur.
Eins og sést í línu merktri númer 20 er athugasemdin svo löng að hún birtist okkur sem tvær línur en hún er í keyrslu tölvunnar álitin ein heild línu 20.
Þess vegna þurfum við ekki að hafa áhyggjur af þessum inndrætti sem birtist, hann er í rauninni ekki til staðar þar sem þessi hluti textans er ein heild.
Einnig eru þarna bil á milli talna fremst í línu og tákna, það er líka til að gera kóðan læsilegri, bilin mega bara ekki vera fremst í línunni enn sem komið er.
Athugasemdir í kóða eru mjög mikilvægur hluti af skjölun kóða og ættu öll sem vilja tileinka sér forritun að venja sig á að skrifa athugasemdir.
Í fyrstu erum við ekki að skrifa flókinn kóða svo athugasemdirnar segja okkur ekki mikið, en þegar kóðinn er ekki augljós eða lausn á verkefni ekki augljós er gott að skrifa athugasemdir.
Flest allir kóðabútar eru skjalaðir með athugasemdum til að gera þá læsilegri því allur kóði í bókinni er skrifaður fyrir fólk til að skilja.
Kóði sem þið komið til með að skrifa seinna meir á einnig að vera ykkur sjálfum skiljanlegur þegar þið komið að honum seinna.
Því er gott að venja sig strax á að skrifa lýsandi athugasemdir. 

\begin{lstlisting}[caption=Reikniaðgerðir, label=lst:reiknadg]
# Samlagning framkvæmd með + 
# Þegar eftirfarandi kóði er keyrður ætti útkonan að vera 10
6 + 4 

# Frádráttur framkvæmdur með -
# Þegar eftirfarandi kóði er keyrður ætti útkonan að vera 10
14 - 4 

# Margföldun framkvæmd með * 
# Þegar eftirfarandi kóði er keyrður ætti útkonan að vera 10
10 * 2 

# Deiling framkvæmd með / 
# Athugið að þetta er fleytitöludeiling sem skilar nákvæmu svari
# Þegar eftirfarandi kóði er keyrður ætti útkonan að vera 10.0
60 / 6 

# Heiltöludeiling framkvæmd með //
# Athugið að þessi deiling er frábrugðin þeirri sem þið kannist við
# Hér viljum við vita hversu oft, heil tala, ein tala gengur upp í aðra og okkur er sama um afganginn
# Þegar eftirfarandi kóði er keyrður ætti svarið að vera 10
177 // 17

# Veldishafning framkvæmd með **
# Hér er mikilvægt, eins og með deilinguna, að hafa í huga hvor talan kemur á undan.
# Fyrst kemur talan sem hefja á í veldi og svo kemur talan sem er veldisvísirinn
# Þegar eftirfarandi kóði er keyrður ætti svarið að vera 9
3 ** 2

# Leifareikningur framkvæmdur með % (e. modulus)
# Þetta er eitthvað alveg nýtt og framandi, en þó ekki óskiljanlegt
# Það sem þetta reiknar er hversu mikil leif eða afgangur er eftir þegar heiltöludeilingu er beitt.
# Þegar eftirfarandi kóði er keyrður ætti svarið að vera 7
177 % 17

\end{lstlisting}

Í öllum þessum dæmum var verið að vinna með heiltölur, þó var útkoman úr deilingunni (stundum kölluð fullkomin deiling) fleytitala. 
Hvað gerist ef þessir sömu útreikningar eru gerðir með fleytitölum? 
Ef við myndum skipta út hverri tölu fyrir sig og setja í staðinn sömu tölu með .0 fyrir aftan þá yrðu útkomurnar þær sömu nema fleytitölur. 
En hvað gerist ef við breytum aðeins fyrri tölunni en ekki seinni tölunni?
Þá ertu að nota ólíkar týpur og slíkt er vandmeðfarið, en í þessu tilviki er það í lagi þar sem Python gerir þá ráð fyrir að það sé í lagi að reikna allt með fleytitölum og framkvæmir reikninginn eins og þú hafir verið að beita fleytitölum í hvívetna og niðurstaðan verður þá að sjálfsögðu fleytitala.

\section{Breytur}\index{Breytur}
Nú höfum við séð hvernig má keyra kóða einfaldlega eins og í reiknivél.
Höldum okkur við samlíkinguna um reiknivélina til að útskýra breytur.
Á hefbundinni reiknivél sem notuð er í stærðfræðitíma í framhaldsskóla er takki sem á stendur ANS.
Það stendur fyrir answer og ef ýtt er á hann getur vélin geymt síðasta gildið sem hún gaf sem svar og unnið svo með það til að gefa næsta svar.
Flottari vélar geta svo geymt nokkuð mörg svör en það er útfyrir gagnsemi þessarar samlíkingu.
Þegar ýtt er á þennan takka er minnisvæði í reiknivélinni tekið frá og skrifað er í það gildi, sem er svo sótt þegar ANS er notað í útreikningi.
Að sama skapi má láta Python úthluta minnissvæði í tölvunni fyrir þær breytur sem þið viljið geyma.
Munurinn er sá að þið nefnið sjálf hvað minnisvæðið er merkt sem, eruð ekki bundin við að nota ANS og að þið eruð svo gott sem með óteljandi minnissvæði.

Að gefa minnissvæði merkingu og gildi er gert með \textit{gildisveitingu}.
Gildisveiting þýðir að nú er einhver ákveðinn merkimiði kominn með eitthvað til að geyma.
Sjáum einfalt dæmi um þetta.

\begin{lstlisting}[caption=Breytur kynntar]
# Hér er ég að fara að búa til breytu sem heitir val
val = 5

# Þegar ég keyri línuna fyrir ofan segi ég vélinni að hafa aðgengilegt minnisvæði sem ég get notað með því að skrifa orðið val, og settu í það svæði gildið 5.

# Svo ég er að veita breytunni val gildið 5, þess vegar er það kallað gildisveiting.

# Svo get ég notað breytuna mína
# þegar þetta er keyrt fæst svarið 10
val + 5
\end{lstlisting}

Ef þú prófar þig áfram við að búa til breytur gætir þú rekist á svolítið sem hefur ekki gerst áður í vinnubók, að þegar sella inniheldur eingöngu gildisveitingu og er keyrð þá ,,gerist ekkert''.
Þetta finnst mörgum mjög skrýtið því þau vilja fá einhverja útkomu.
En útkoman er sú að þú sagðir vélinni að geyma þetta, þú sagðir henni ekki að gera neitt annað.

Breytur eru skilgreindar vinstra megin við jafnaðarmerki í Python.
Eins og það væri lesið, val fær gildið 5.
Það væri lítið vit í því að hafa það öfugt, 5 er núna jafngilt val.
Það sem við værum þá að segja tölvunni að í hver sinn sem hún vill nota heiltöluna fimm þá á hún að hætta við að nota töluna sjálfa og í staðinn vísa eingöngu í það sem er í minnissvæði merktu val.
Það er alls ekki það sem við viljum.

Nokkrar reglur í nafnavali á breytum, þetta vill vefjast fyrir sumum en lærist fljótlega:
\vspace{0.5cm}
\begin{enumerate}
	\item Kóðalitunin á breytuheitinu má ekki vera annað en venjulegi liturinn fyrir kóða, þannig að ef nafnið fær áherslumerkingu (annan lit) er það ekki löglegt breytuheiti. 
	Áherslulitunin í númeruðu kóðabútunum í þessari bók er marklaus því hún er mjög frumstæð.
	Dæmi um það sem fær áherslulitun eru frátekin lykilorð og tölustafir.
	\item Breytuheitið ætti ekki að innihalda séríslenskan staf (það er löglegt í jupyter vinnubókum en er hrikalega slæmur ávani því það er ekki löglegt allsstaðar).
	\item Breytuheitið má ekki innihalda bil.
\end{enumerate}
\vspace{0.5cm}
Nokkur tilmæli um breytunöfn með tilliti til nafnavenja í Python:
\vspace{0.5cm}
\begin{enumerate}
	\item Breytuheiti byrja á litlum staf.
	\item Ef það þarf að gera löng breytuheiti er venjan að nota snákaframsetningu (e. snake casing) sem felur í sér að gera niðurstrik á milli orða, dæmi \texttt{thetta\_er\_langt\_nafn\_a\_breytu}.
	Annars er til kamelframsetning (e. camel casing) sem felur í sér að annað hvert orð er með stórum staf, dæmi \texttt{thettaErLikaLangtBreytuheiti}.
	Hvort sem þið endið á að nota meira, haldið ykkur bara við annað þeirra.
	\item Breytuheiti eiga að vera lýsandi.
	Ef ég væri að reikna hliðar í þríhyrningi væri gott að eiga breyturnar \texttt{a}, \texttt{b} og \texttt{c}.
	En ef ég væri að búa til reiknirit sem býr til tölvuleikjapersónu af handahófi með því að velja tilviljanakennt nafn, aldur og starf þá væru breytuheitin \texttt{a}, \texttt{b} og \texttt{c} alveg glötuð því þegar ég kæmi aftur að kóðanum mínum myndi ég ekki hafa hugmynd um hvað a, b og c væru. 
	Betra væri að breyturnar hétu \texttt{nafn}, \texttt{aldur} og \texttt{starf}.
\end{enumerate}

\begin{lstlisting}[caption=Dæmi um gildisvetingar\, réttar og rangar]
# Hér er ég að fara að búa til breytu sem heitir val
val = 5

# Hér er ég ekki að búa til breytu sem heitir val heldur er ég að segja að talan fimm er ekki lengur til sem heiltala heldur gæti hún vísað í hvað sem er sem er geymt í minnisvæði merktu val, ólöglegt.
5 = val

# Hér bý ég til breytu sem heitir heiltala sem fær gildið 0
heiltala = 0

# Hér yfirskrifa ég lykilorðið fyrir týpuna heiltala og læt það innihalda 0
int = 0
# þetta er harðbannað og ef þetta gerist er ekki nóg að þurrka þetta út og keyra aftur, nú þarf að endurræsa kjarna vinnubókarinnar.

Gott nafn = 1.0
# Þetta er ekki bara bannað vegna bilsins á milli orðanna ,,Gott'' og ,,nafn'' heldur er það líka ljótt því að það byrjar á stórum staf

3_litlar_mys = 3
# má ekki byrja á tölustaf eða tákni

utreiknud_laun_eftir_skatt = 0.65 * laun
# frábært, lýsandi og gott breytuheiti (hér er þó gert ráð fyrir að vélin þekki breytuna laun)
\end{lstlisting}

Nú þegar við höfum séð hvernig má skilgreina breytu viljum við vita hvernig á að nota þessa breytu.
Ef við snúum okkur aftur að reiknivélasamlíkingunni um ANS takkann þá ætti kóðabútur \ref{lst:notabreytu} að geta sýnt með eðlislægum hætti hvernig breytur nýtast.
Fyrst segi ég vélinni hvað það er sem ANS vísar á, svo segi ég vélinni að mig langar til þess að búa til nýja breytu sem á að byggja á því sem ANS inniheldur.
Í þessum kóðabút er svo haldið áfram með þessa afleiddu breytu og önnur afleidd breyta búin til útfrá henni.
Það sem gerist svo í endann er sambærilegt við það að ýta á ,,='' takkann á reiknivélinni.
Takið eftir að þarna er notuð ný framsetning sem við höfum ekki séð áður, þarna stendur print með svigum fyrir aftan og inni í svigunum er breytan okkar.
Ef þessi kóðabútur er keyrður þá kemur á \textit{staðalúttak} 
\footnote{Þann stað sem texti myndi prentast þegar forritið er notað, hvort sem það er á skjá eða beint á pappír úr prentara eða eitthvað allt annað. Kannski verður úttaki varpað beint inn í heilann á forriturum einhvern tíma?} 
það gildi sem breytan \textbf{x} inniheldur.
Ef þar hefði staðið \texttt{print(halft\_x)} hefðum við fengið svarið sem er geymt í breytunni \texttt{print(halft\_x)}.

\begin{lstlisting}[caption=Að nota breytu, label=lst:notabreytu]
# Hér framkvæmi ég einhvern útreikning sem ég geymi í breytunni ANS
ANS = 5**2 + (4+8.9)**2

# Segjum að þetta hafi verið endapunkturinn í löngu algebrudæmi og nú veit ég hvað y er, og get þá nýtt það til að finna x eins og verða vill svo oft í stærðfræði að x sé týnt. Gefum okkur að x = 3 * y og því fæst
x = 3 * ANS

# Nú ef við viljum reikna eitthvað út með x eigum við það til í minnissvæði merktu x með réttu gildi. Til dæmis með því að búa til breytu fyrir hálft x.
halft_x = x/2


# Nú langar okkur til að vera viss um að við séum við vitrænt svar svo við biðjum tölvuna um að segja okkur hvað er geymt í breytunni x.
print(x)

\end{lstlisting}

Við megum beita print skipuninni óspart og hvetur höfundur til þess að lesandi venji sig á að skoða úttakið sitt í hverju þrepi áður en leitað er hjálpar til annarra.
Print er \textit{fall}, við skoðum föll nánar í kafla \ref{k:föll} en þangað til munum við kynnast nokkrum innbyggðum föllum eins og print().

Núna höfum við séð tvær týpur, heiltölur og fleytitölur.
Breyta getur innihaldið hvernig týpu sem er.
Þá þurfum við að athuga hvað má gera við breyturnar okkar.
Hingað til höfum við eingöngu skoðað reikniaðgerðir sem eru framkvæmdar með kunnuglegum táknum, við höfum ekki verið að beita neinum innbyggðum \textit{aðferðum} á tölurnar okkar.
Við sjáum það gert í kafla \ref{k:strengir} þegar við skoðum hvernig megi vinna með texta.

Að því sögðu þá þurfum við að skoða breytur nokkuð betur áður en við förum að beita þeim á skilvirkan hátt.
Við erum búin að skoða reiknivirkja og gildisveitingu, og nú ætlum við að skoða \textit{reiknivirkjagildisveitingu} þar sem við uppfærum gildi í breytu með því að nota reiknivirkja eins og + eða - með gildisveitingu =.
Þetta sést betur í kóðabút

\begin{lstlisting}[caption="Reiknivirkjagildisveiting", label=lst:reiknivirkjagildisveiting]
# ég ætla að telja nemendur inn í stofuna
# ég byrja með 0 nemendur
nem = 0

# svo sé ég fyrsta nemandann minn og endurskilgreini þar með breytuna nem
nem = nem + 1

# þá uppfæri ég gildið sem nem breytan inniheldur og er hún núna það sem hún var (0) + 1, ef ég keyrði þessa línu aftur væri það orðið að (1) + 1 og svo koll af kolli eftir því sem ég keyri þessa línu oftar

# önnur leið til að skrifa þetta er með reiknivirkjagildisveitingu
nem += 1

# þá uppfæri ég gildið nem um það sem hún var + 1

#segjum að nemendur koma inn í stofuna í pörum þá væri formúlan svona:
nem += 2

# þá uppfærist gildið í nem um +2 í hvert sinn sem þessi kóðalína er keyrð

# Ef ég væri að reikna stofnstærð á bakteríum sem tvöfaldast á hverjum klukkutíma gæti ég gert það svona:
stofn_staerd = 30
stofn_staerd *= 2 # og keyrt svo þessa línu fyrir hvern klukkutíma

# Tökum annað dæmi, byrjum á að skoða hvernig megi geyma útreikninga í mismunandi breytum
thusund = 1000
fimm_hundrud = thusund/2
tvo_hundrud_og_fimmtiu = fimm_hundrud/2

# ef ef mér er sama um breytuna thusund og vil þess í stað bara halda utan um alla upphæðina mína í einni breytu og helminga hana tvisvar þá get ég gert þetta
allt = 1000
allt /= 2
allt /= 2

#nú er allt orðið að 250

# ég má líka nota aðrar breytur í uppfærslunni minni
# hér ætla ég að reikna út hver hækkun launa yrði milli ára ef ég fengi alltaf 2% launahækkun

laun = 100
verdbolga = 0.02
laun *= 1 + verdbolga # þetta má svo keyra endurtekið til að skoða fram í tímann

\end{lstlisting}

Hér sést að það er gagnlegt og fljótlesið þegar það á að uppfæra gildi á breytu að gera það með því að nota reiknivirkjann með gildisveitingunni.
Í kóðabútnum að ofan sést að athugasemdir eru skrifaðar inni í línum líka, það er stundum gagnlegt að skrifa stuttar athugasemdir inni í kóða með þessum hætti en betra er þó að skjala hann skilmerkilega efst við viðeigandi kóðabút.
Allar athugasemdir eru hunsaðar af vélinni og því hefur allt sem er fyrir aftan \# merkið, hver sem það er, engin áhrif á útkomuna.

\section{Villur}\index{Villur}\label{uk:tolur-villur}
Að svo stöddu er gott að hafa í huga hinar ýmsu villur sem geta komið upp.
Þegar við forritum í Python fáum við yfirleitt í hendurnar mjög lýsandi villur sem segja okkur hvað við gerðum vitlaust og hvar.
Áður en lengra er haldið er vitlegt að kynnast þeim algengu villum sem koma upp, hvað þær þýða og hvernig á að taka á þeim.

\begin{itemize}
	\item Nafna villa (e. NameError), þar sem við reyndum að nota breytu sem við höfum enn ekki skilgreint.
	Þessi villa kemur upp þegar við skrifum nafnið á breytunni okkar vitlaust þegar við ætlum að beita henni eða við gleymdum að skilgreina hana áður en við beittum henni.
	Til dæmis myndum við fá nafnavillu við að skilgreina breytuna Valborg en nota svo breytuna valborg, þar sem hástafir og lágstafir skipta máli í Python og eru þessar tvær breytur algerlega óskyldar í minninu.
	Einnig getur þessi villa komið upp þegar við ætlum að nota strengi en gleymum að skilgreina þá sem strengi með gæsalöppum og látum vélina halda að við séum að vinna með breytur.
	Sjáum í kafla \ref{k:strengir} hvernig á að skilgreina strengi.
	
	Þetta lögum við með því að sjá hvaða nafn við ætluðum að nota og pössum okkur að það nafn hefur fengið einhverja skilgreiningu áður en að við reynum að nota það (það er ofar í kóðanum).
	
	\item Týpu villa (e. TypeError), þar sem eitthvað var gert við gögn sem týpan af gögnunum leyfir ekki.
	Til dæmis að beita reiknivirkja á breytu sem styður ekki notkun hans.
	\item Málskipunar villar (e. SyntaxError), þar sem eitthvað var vitlaust skrifað, vitlaust tákn á vitlausum stað.
	Til dæmis var komma notuð í stað punkts eða breytuheiti byrjaði á tákni eða tölu.
	
	Það sem við gerum í því að fá þessa villu er að lesa okkur til um hvað það er sem má gera við týpuna okkar og athuga hvernig við fáum fram þá virkni sem við vildum með því að leysa vandann á annan máta.
	Hér erum við í rauninni að misskilja hvað má og hvað má ekki og við þurfum að átta okkur betur á því hvað er í boði.
	
	\item Inndráttar villa (e. IndendationError), þar sem kóðinn er ekki rétt inndreginn.
	Eins og kom fram í inngangi þá þarf Python kóði að vera vel uppsettur til þess að hann keyri.
	Við sjáum fyrst í kafla \ref{k:segðir} hvernig við beitum inndrætti svo núna ef við fáum þessa villu þá er það vegna þess að við erum með óþarfa bil fyrir framan kóðann okkar. 
	
	Það sem við gerum er að skilja hvað á að vera í hvaða inndrætti og laga kóðann þannig að hann sé vel uppsettur.
	
	\item Vísis villa (e. IndexError), þar sem við reyndum að ná í sætisvísi sem er ekki til í gögnunum okkar.
	Í kafla \ref{k:strengir} sjáum við týpu sem hefur sætisvísa.
	
	Það sem við gerum í þessari villu er að átta okkur á því hversu margir sætisvísar eru til staðar og hvaða vísa við vildum fá, laga svo kóðann í samræmi við það sem við ætluðum að sækja.
	
	\item Gildis villa (e. ValueError), þar sem við reyndum að ná í eða nota gildi úr gögnum sem er ekki til.
	Gögnin eru til en gildið er ekki til staðar í þeim.
	
	Athugum hér að við reyndum að sækja eitthvað, næstum því eins og upp úr poka, og í stað þess að segja áttu þetta til? Þá sögðum við við vélina ,,þú átt þetta til, láttu mig hafa það!''. Svo það sem við getum gert til að laga það er að segja ,,áttu þetta til?'' eða ,,reyndu að láta mig hafa það ef þú átt það''. 
	Þessi lausn er ansi óljós að svo stödu þar sem við höfum ekki farið yfir hvernig á að ná í gildi upp úr gögnunum okkar en vonandi verður þetta ljósara þegar þar að kemur.
	
	\item Eiginda villa (e. AttributeError), þar sem við reynum að ná í eða beita eigindum sem gögnin okkar búa ekki yfir.
	Við getum séð hvaða eigindum gögnin okkar búa yfir með því að lesa skjölun um þau eða kíkja snöggt undir húddið með því að gera punkt fyrir aftan gögnin og ýta á tab takkann \todo{vísa hérna aftur í tab takkann} og þá sjáum við þau eigindi sem týpan býr yfir.
	Ef við skoðum þau eigindi sem eru til fyrir heiltölur og fleytitölur sjáum við að þau eru ekki alveg eins og ef við reynum að nota þau sem eru til fyrir annað en ekki hitt á víxl þá fáum við eigindavillu.
	
	Það sem við gerum í þessu er svipað týpu villunni, það er að lesa okkur til um hvaða eigindi gögnin okkar búa yfir og hvað við getum náð í og notað.
	Eigindi eru mismunandi eftir týpum og er mikilvægt að átta sig á því hvaða eigindi eru í boði hverju sinni svo að við veljum rétta týpu fyrir gögnin okkar.
\end{itemize}

\section{Verkefni}
\begin{exercise}\label{tol1}
		Búðu til breytu sem inniheldur heiltölu
	\end{exercise}
\setboolean{firstanswerofthechapter}{true}
	\begin{Answer}[ref={tol1}]
		Nú þurfum við að athuga þrennt nafn á breytuna, hvernig á að veita henni eitthvað gildi og sjá til þess að það gildi sé heiltala.
		Til þess að búa til breytu þarf að finna nafn á hana, skrifa það fremst í línuna (ss. vinstra megin við jafnaðarmerkið) og nota svo jafnaðarmerkið til þess að veita breytunni gildi og því næst velja einhverja heila tölu.
		Það er tölu sem er annað hvort jákvæð eða neikvæð og er ekki með punkt og aukastafi.
	\begin{lstlisting}
		# til dæmis
		eitthvad_loglegt_breytuheiti = 5
		neikvaed_tala = -1234567890
	\end{lstlisting}
\end{Answer}
\setboolean{firstanswerofthechapter}{false}

\begin{exercise}\label{tol2}
	Búðu til breytu sem inniheldur fleytitölu
\end{exercise}
\begin{Answer}[ref={tol2}]
	Hér þurfum við að hafa það sama í huga eins og í æfingu \ref{tol1} nema að talan sem við veljum okkur verður að vera með punkti og einum eða fleiri aukastöfum.
	\begin{lstlisting}
		# til dæmis
		eitthvad_loglegt_breytuheiti = 5.0
		neikvaed_tala = -12.9999
	\end{lstlisting}
\end{Answer}


\begin{exercise}\label{tol3}
	Gefum okkur að við eigum eftirfarandi kóða, hvernig fáum við breytuna helmingur til að innihalda helminginn af því sem er í breytunni allt.
	Nú megum við ekki bara skrifa inn töluna 1000 í útreikninginn, við þurfum að beita breytunni \textit{allt} því að hún gæti breyst og við viljum ekki að kóðinn okkar gefi vitlaust svar ef \textit{allt} breytist.
	Einnig viljum við búa til þriðju breytuna sem á að vera helmingurinn af helmingnum, hvernig fáum við helminginn af breytunni \textit{helmingur}.
	\begin{lstlisting}
		allt = 1000
		helmingur =\end{lstlisting}
\end{exercise}
\begin{Answer}[ref={tol3}]
	Við beitum deilingu á breytuna allt, og svo gerum við það aftur fyrir nýju breytuna.
	\begin{lstlisting}
		allt = 1000
		helmingur = allt/2
		helmingurinn_af_helmingnum = helmingur/2
		
		# eða
		allt = 1000
		helmingur = allt/2
		helmingur_af_helmingnum = allt/2/2  # eða allt/4 því helmginur af helmingnum er fjórðungur
	\end{lstlisting}
\end{Answer}


\begin{exercise}\label{tol4}
	Nú langar okkur að reikna helminginn af breytunni \textit{allt} alveg eins og í verkefni \ref{tol3} nema við viljum alls ekki geyma niðurstöðurnar í breytu heldur viljum við hafa áhrif á breytuna \textit{allt}.
	Hvernig getum við prentað út fyrst helminginn af \textit{allt} og svo helminginn af því?
\end{exercise}
\begin{Answer}[ref={tol4}]
	Við beitum deilingu á breytuna allt, og svo gerum við það aftur fyrir nýju breytuna.
	\begin{lstlisting}
		allt = 1000
		print(allt)
		
		allt /= 2
		print(allt)
		
		allt /= 2
		print(allt)
	\end{lstlisting}
\end{Answer}

\begin{exercise}\label{tol5}
	Hvernig fyllirðu inn í eftirfarandi kóða þannig að hann reikni út langhlið í rétthyrndum þríhyrningi?
	Þar sem a og b eru skammhliðar þríhyrningsins og þær þarf að skilgreina sem einhverjar stærðir áður en hægt er að reikna c.
	\begin{lstlisting}
		??
		??
	
		c_i_odru_veldi = a**2 + b**2
		c = c_i_odru_veldi**0.5
		print(c)\end{lstlisting}
\end{exercise}
\begin{Answer}[ref={tol5}]
	Hér þurfum við að átta okkur á því að vélin býst við að nota breyturnar a og b en við eigum eftir að skilgreina þær sem eitthvað.
	Þekktur rétthyrndur þríhyrningur er til dæmis með hliðarnar 3, 4 og 5.
	\begin{lstlisting}
		a = 3
		b = 4
		
		c_i_odru_veldi = a**2 + b**2
		c = c_i_odru_veldi**0.5
		print(c)
	\end{lstlisting}
	Þá er c 5 í þessu tilfelli en hér má setja hvaða tölur inn sem er til að komast að því hvað c þyrfti að vera löng hlið til þess að þríhyrningurinn sé rétthyrndur.
\end{Answer}